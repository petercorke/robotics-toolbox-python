

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Introduction &mdash; Robotics Toolbox for Python 0.3.7
 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Manipulator arms" href="arm.html" />
    <link rel="prev" title="Robotics Toolbox for Python" href="index.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Robotics Toolbox for Python
          

          
            
            <img src="_static/RobToolBox_RoundLogoB.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Introduction</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#a-python-version">A Python version</a></li>
<li class="toctree-l2"><a class="reference internal" href="#spatial-math-layer">Spatial math layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#robotics-toolbox">Robotics Toolbox</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#robot-models">Robot models</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#trajectories">Trajectories</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#symbolic-manipulation">Symbolic manipulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#differential-kinematics">Differential kinematics</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="arm.html">Manipulator arms</a></li>
<li class="toctree-l1"><a class="reference internal" href="mobile.html">Mobile robots</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Robotics Toolbox for Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Introduction</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/intro.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="arm.html" class="btn btn-neutral float-right" title="Manipulator arms" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Robotics Toolbox for Python" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¬∂</a></h1>
<div class="section" id="id1">
<h2>Introduction<a class="headerlink" href="#id1" title="Permalink to this headline">¬∂</a></h2>
<p>The Robotics Toolbox for MATLABtextsuperscript{textregistered} (RTB-M) was created around 1991 to support the first author‚Äôs PhD research and was first published in 1995-6~cite{Corke95d}cite{Corke96j}. It has evolved over 25 years to track changes and improvements to the MATLAB language and ecosystem, such as the addition of structures, objects, lists (cell arrays) and strings, myriad of other improvements to the language, new graphics and new tools such as IDE, debugger, notebooks (LiveScripts), apps and continuous integration.  An adverse consequence is that many poor %(in retrospect)
early design decisions hinder development.</p>
<p>Over time additional functionality was added, in particular for vision, and two major refactorings led to the current state of three toolboxes: Robotics Toolbox for MATLAB and Machine Vision Toolbox for MATLAB (1999) both
of which are built on the Spatial Math Toolbox for MATLAB (SMTB-M) in 2019~cite{Corke17a}.
The code was formally open sourced to support its use for the third edition of John Craig‚Äôs book~cite{craig2005introduction}.
It was hosted on ftp sites, personal web servers, Google code and currently GitHub and maintained under a succession of version control tools including rcs, cvs, svn and git.  A support forum on Google Groups was established in 2008 and currently has over 1400 members.</p>
<p>This paper describes the motivation and design of the Robotics Toolbox for Python, and illustrates key features in a tutorial fashion.</p>
</div>
<div class="section" id="a-python-version">
<h2>A Python version<a class="headerlink" href="#a-python-version" title="Permalink to this headline">¬∂</a></h2>
<p>The imperative for a Python version has long existed and the first port was started in 2008 but ultimately failed for lack of ongoing resources to complete a sufficient subset of functionality.
Subsequent attempts have all met the same fate.</p>
<p>The design goals of this version can be summarised as new functionality
begin{itemize}
item A superset of the MATLAB Toolbox functionality
item Build on the Spatial Math Toolbox for Python which provides objects to represent rotations as matrices SO{2} and SO{3} as well as unit-quaternions, rigid-body motions as matrices SE{2} and SE{3} matrices as well as twists in SE{2} and SE{3}, and Featherstone‚Äôs spatial vectors~cite{Featherstone87}.
item Support models expressed using Denavit-Hartenberg notation (standard and modified), elementary transform sequences~cite{ets1, ets2}, and URDF-style rigid-body trees.  Support branched, but not closed-loop or parallel, robots
item Collision checking
end{itemize}
and improved software engineering
begin{itemize}
item Use Python 3 (3.6 and greater)
item Utilize WebGL and Javascript graphics technologies
item Documentation in ReStructured Text using Sphinx and delivered via GitHub pages.
item Hosted on GitHub with continuous integration using GitHub actions
item High code-quality metrics for test coverage and automated code review and security analysis
item As few dependencies as possible, in particular being able to work with ROS but not be dependent on ROS. This sidesteps ROS constraints on operating system and Python versions.
item Modular approach to interfacing to different graphics libraries, simulators and physical robots.
item Support Python notebooks which allows publication of static notebooks (for example via GitHub) and interactive online notebooks (MyBinder.org).
item Use of UniCode characters to make console output easier to read
end{itemize}</p>
<p>subsection{Related work}
There are a number of Python-based packages for robotics, each reflecting different design approaches or requirements and with
various levels of finish in terms of documentation, examples, and continuous integration.</p>
<p>PythonRobotics~cite{py1} and Klampt~cite{py2}  offer a focus on autonomous navigation and planning. While differing in scope to this work, PythonRobotics features excellent documentation and code quality, making it an exemplar.</p>
<p>Numerous packages have a focus on dynamics including iDynTree~cite{py4}, Siconos~cite{py5}, PyDy~cite{py6}, DART~cite{py7}, and PyBullet~cite{py3}. PyBullet and DART both feature graphical simulations, physics simulation, dynamical modelling, and collision detection making them useful robotics toolkits. These two packages are written in C++ with Python bindings making them fast and efficient, while still being usable in a Python environment. However, although both packages are feature-rich, they lack the ease of use and intuitive interfaces provided by  emph{pythonic} development-driven applications. Siconos, iDynTree, and PyDy focus on multibody dynamics for model specification, simulation and benchmarking.</p>
<p>The pybotics~cite{py8} robotics toolkit focusses on robot kinematics but is limited to Modified Denavit‚ÄìHartenberg notation. A similar work, python-robotics~cite{py0}, was created due to the author‚Äôs inspiration by RTB-M and dissatisfaction with Python-based alternatives~cite{edu}. The package, while far from a RTB-M clone or conversion, contains useful functionality for robotics education.</p>
<p>Our reinvented toolbox: The Robotics Toolbox for Python, promises to encapsulate an extensive scope of robotics, from low-level spatial-mathematics to robot arm kinematics and dynamics (regardless of model notation), and mobile robots, provide interfaces to graphical simulators and real robots,
while being a pythonic, well documented, and well maintained with applications in research, education, and industry.</p>
</div>
<div class="section" id="spatial-math-layer">
<h2>Spatial math layer<a class="headerlink" href="#spatial-math-layer" title="Permalink to this headline">¬∂</a></h2>
<p>Robotics and computer vision require us to describe position, orientation and pose in 3D space.
Mobile robotics has the same requirement, but generally for 2D space.
We therefore need tools to represent quantities such as rigid-body transformations (matrices $in mbox{SE(n)}$
or twists $in mbox{se}(n)$), rotations (matrices $in mbox{SO(n)}$ or mbox{so(n)}, Euler or roll-pitch-yaw angles,
or unit quaternions $in S^3$).
Such capability is amongst the oldest in RTB-M and the equivalent functionality exists in RTB-P which makes use of the Spatial Maths Toolbox for Python (SMTB-P)footnote{url{<a class="reference external" href="https://github.com/petercorke/spatialmath-python">https://github.com/petercorke/spatialmath-python</a>}}.
For example</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">spatialmath.base</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">transl</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">@</span> <span class="n">rpy2tr</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span> <span class="o">@</span> <span class="n">trotx</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="s1">&#39;deg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">[[ 0.9752 -0.1987 -0.0978  0.5   ]</span>
<span class="go"> [ 0.1538  0.2896  0.9447  0.    ]</span>
<span class="go"> [-0.1593 -0.9363  0.313   0.    ]</span>
<span class="go"> [ 0.      0.      0.      1.    ]]</span>
</pre></div>
</div>
<p>There is strong similarity to the equivalent MATLAB case apart from the use of the code{&#64;} operator, the use of keyword arguments instead
of keyword-value pairs, and the format of the printed array.
All the <a href="#id2"><span class="problematic" id="id3">``</span></a>classic‚Äô‚Äô RTB-M functions are provided in the code{spatialmath.base} package as well as additional
functions for quaternions, vectors, twists and argument handling.  There are also functions to perform interpolation,
plot and animate
coordinate frames, and create movies, using matplotlib.
The underlying datatypes in all cases are 1D and 2D NumPy arrays.
For a user transitioning from MATLAB the most significant difference is the use of 1D arrays ‚Äì all
MATLAB arrays have two dimensions, even if one of them is equal to one.</p>
<p>However some challenges arise when using arrays, whether native MATLAB matrices or NumPy arrays as in this case.
Firstly, arrays are not typed and for
example a $3 times 3$ array could be an element of $mbox{SE{2}}$ or $mbox{SO{3}}$ or an arbitrary matrix.</p>
<p>Secondly, the operators we need for poses are a subset of those available for matrices, and some operators may need to be redefined
in a specific way.
For example, $SE{3} * SE{3} rightarrow SE{3}$ but $SE{3} + SE{3} rightarrow mathbb{R}^{4 times 4}$, and equality testing for a unit-quaternion has to respect the double mapping.</p>
<p>Thirdly, in robotics we often need to represent time sequences of poses.  We could add an extra dimension to
the matrices representing rigid-body transformations or unit-quaternions, or place them in a list.  The first approach
is cumbersome and reduces code clarity, while the second cannot ensure that all elements of the list have the
same type.</p>
<p>We  use classes and data encapsulation to address all these issues.
SMTB-P provides abstraction classes code{SE3}, code{Twist3}, code{SO3}, code{UnitQuaternion}, code{SE2}, code{Twist2} and code{SO2}. For example, the previous example could be written as</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">T</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">SE3</span><span class="o">.</span><span class="n">RPY</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Rx</span><span class="p">(</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;deg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="go">  [38;5;1m 0.97517    [0m[38;5;1m-0.198669   [0m[38;5;1m-0.0978434  [0m[38;5;4m 0.5        [0m  [0m</span>
<span class="go">  [38;5;1m 0.153792   [0m[38;5;1m 0.289629   [0m[38;5;1m 0.944702   [0m[38;5;4m 0          [0m  [0m</span>
<span class="go">  [38;5;1m-0.159345   [0m[38;5;1m-0.936293   [0m[38;5;1m 0.312992   [0m[38;5;4m 0          [0m  [0m</span>
<span class="go">  [38;5;244m 0          [0m[38;5;244m 0          [0m[38;5;244m 0          [0m[38;5;244m 1          [0m  [0m</span>

</pre></div>
</div>
<p>where composition is denoted by the * operator and the matrix is printed more elegantly (and elements are color
coded at the console or in ipython).
code{SE3.RPY()} is a class method that acts like a constructor, creating an code{SE3} instance from a set of roll-pitch-yaw angles,
and code{SE3.Rx()} creates an code{SE3} instance from a pure rotation about the x-axis.
Attempts to compose with a non code{SE3} instance would result in a code{TypeError}.</p>
<p>The orientation of the new coordinate frame may be expressed in terms of Euler angles</p>
<p>the rotation matrix can be easily extracted</p>
<p>and we can plot the coordinate frame
begin{Code}
&gt;&gt;&gt; T.plot(color=‚Äôred‚Äô, label=‚Äô2‚Äô)
end{Code}
Similar constructors allow object construction with orientation expressed in terms of an angle-vector pair or orientation
and approach vectors.</p>
<dl class="simple">
<dt>begin{figure}</dt><dd><p>centering
includegraphics[width=columnwidth]{figs/pose-values.pdf}
caption{Any of the SMTB-P pose classes can contain a list of values}
label{fig:values}</p>
</dd>
</dl>
<p>end{figure}
begin{figure}</p>
<blockquote>
<div><p>centering
includegraphics[width=columnwidth]{figs/broadcasting.pdf}
caption{Overloaded operators support broadcasting.}
label{fig:broadcasting}</p>
</div></blockquote>
<p>end{figure}</p>
<p>Rotation can also be represented by a unit quaternion</p>
<p>which again demonstrates several alternative constructors.
The classes are somewhat polymorphic and have the same constructors for canonic rotations, Euler and roll-pitch-yaw angles, angle-vector,
as well as a random value.  SE{n} and SO{n} also support a matrix exponential constructor where the argument is the
corresponding Lie algebra element.</p>
<p>To support trajectories each of these types inherits list properties from code{collections.UserList}
as shown in Figure ref{fig:values}.
We can index the values, iterate over the values, assign to values.
Some constructors take an array-like argument allowing creation of multi-valued pose objects,
for example</p>
<p>where the instance code{R} contains a sequence of 100 rotation matrices.
Composition with a single-valued (scalar) pose instance  broadcasts the scalar
across the sequence as shown in Figure ref{fig:broadcasting}.</p>
<p>The types all have an inverse method code{.inv()} and support composition with the inverse using the code{/} operator
and integer exponentiation (repeated composition) using the code{**} operator.
Other overloaded operators include <em>, *=, *</em>, <a href="#id4"><span class="problematic" id="id5">**</span></a>=, /, /=, ==, !=, +, -.
Supporting classes include code{Quaternion} and code{Plucker}</p>
<p>All of this allows for concise and readable code.
The use of classes ensures type safety and that the matrices abstracted by the class are always valid members of
the group.
Operations such as addition which are not group operations yield a NumPy array rather than a class instance.</p>
<p>These benefits come at a price in terms of execution time due to the overhead of constructors and methods which wrap base functions, and type checking.
The Toolbox supports SymPy which provides powerful symbolic support for Python and it works well in conjunction with NumPy, ie. a NumPy array can contain symbolic elements.  Many the Toolbox methods and functions contain extra logic to ensure that symbolic operations work as expected. While this adds to the overhead it means that for the user, working with symbols is as easy as working with numbers.
%To put this in perspective, performance
Performance on a 3.6unit{GHz} Intel Core i9 is shown in Table ref{tab:timing}.</p>
</div>
<div class="section" id="robotics-toolbox">
<h2>Robotics Toolbox<a class="headerlink" href="#robotics-toolbox" title="Permalink to this headline">¬∂</a></h2>
<div class="section" id="robot-models">
<h3>Robot models<a class="headerlink" href="#robot-models" title="Permalink to this headline">¬∂</a></h3>
<p>The Toolbox ships with over 30 robot models, most are purely kinematic but some have inertial and frictional parameters.
Kinematic models can be specified in a variety of ways:  standard or modified Denavit-Hartenberg (DH, MDH) notation, as an ETS string~cite{ets1},
as a rigid-body tree, or from a URDF file.</p>
<p>begin{table}
centering
begin{tabular}{<a href="#id16"><span class="problematic" id="id17">|l|l|</span></a>}hline
Function/method &amp; Execution time \ hline
code{base.rotx()} &amp;     4.07 unit{mu s} \
code{base.trotx()} &amp;    5.79 unit{mu s} \
code{SE3.Rx()} &amp;             12.3 unit{mu s} \
code{SE3 * SE3} &amp;              4.69 unit{mu s} \
code{4x4 &#64;} &amp;              0.986 unit{mu s} \
code{SE3.inv()} &amp;             7.62 unit{mu s} \
code{base.trinv()} &amp;          4.19 unit{mu s} \
code{np.linalg.inv()} &amp;       4.49 unit{mu s} \ hline
end{tabular}
caption{Spatial math execution performance}
label{tab:timing}
end{table}</p>
<p>subsubsection{Denavit-Hartenberg parameters}
To specify a kinematic model using DH notation, we create a new subclass of code{DHRobot} and pass the superclass constructor
a list of link objects.  For example, an IRB140 is simply
begin{Code}
&gt;&gt;&gt; robot = DHRobot(</p>
<blockquote>
<div><dl>
<dt>[</dt><dd><blockquote>
<div><p>RevoluteDH(d=d1, a=a1, alpha=-pi/2),
RevoluteDH(a=a2),
RevoluteDH(alpha=pi/2),
‚Ä¶</p>
</div></blockquote>
<p>], name=‚Äùmy IRB140‚Äù)</p>
</dd>
</dl>
</div></blockquote>
<p>end{Code}
where only the non-zero parameters need to be specified.
In this case we used code{RevoluteDH} objects for a revolute joint described using standard DH conventions.  Other classes available
are code{PrismaticDH}, code{RevoluteMDH} and code{PrismaticMDH}.
Other parameters such as mass,  CoG, link inertia, motor inertia, viscous friction, Coulomb friction, and joint limits can also be specified using additional keyword arguments.</p>
<p>We can now easily perform standard kinematic operations
begin{Code}
&gt;&gt;&gt; puma = rtb.models.DH.Puma560()
&gt;&gt;&gt; T = puma.fkine([0.1, 0.2, 0.3, 0.4, 0.5, 0.6])
&gt;&gt;&gt; q, <a href="#id6"><span class="problematic" id="id7">*</span></a>_ = puma.ikine(T)
&gt;&gt;&gt; puma.plot(q)
end{Code}
code{ikine} is a generalised iterative numerical solutioncite{chiaverini-control} based on Levenberg-Marquadt minimization, and additional status results are also returned.
The default plot interface, using matplotlib, produces a <a href="#id8"><span class="problematic" id="id9">``</span></a>noodle robot‚Äô‚Äô plot like that shown in Fig ref{fig:noodle}.</p>
<p>The starting point for the solution may be specified, but
defaults to zero, and affects both the search time and the solution found, since in general
a manipulator may have several poses which result in the same end-effector pose.
For a redundant manipulator a solution will be found but there is no
explicit control over the null-space.  For a manipulator with $n &lt; 6$ DOF
an additional argument is required to indicate which of the
$6-n$ Cartesian DOF are to be unconstrained in the solution.
%Note that a solution is not possible if the specified transform describes
%a point out of reach of the manipulator ‚Äî in such a case the function will
%return with an error.</p>
<p>The inverse kinematic procedure for any specific robot can
be derived symbolically~cite{Paul81a}
and commonly an efficient closed-form solution can be obtained.
Some robot classes have an analytical solution coded, for example
begin{Code}
&gt;&gt;&gt; puma.ikine_a(T, config=‚Äùlun‚Äù)
end{Code}</p>
<p>% begin{figure}
%     centering
%     includegraphics[width=columnwidth]{figs/noodle+ellipsoid.png}
%     caption{A robot rendered using the default matplotlib visualizer.}
%     label{fig:noodle}
% end{figure}</p>
<p>subsubsection{ETS notation}
A Puma robot can also be specified in ETS format~cite{} as a sequence of simple rigid-body transformations, pure translation
or pure rotation, with a constant parameter or a free parameter which is a joint variable
begin{Code}
&gt;&gt;&gt; e = ET.tz(l1) * ET.rz() * ET.ty(l2) * ET.ry()</p>
<blockquote>
<div><ul class="simple">
<li><p>ET.tz(l3) * ET.tx(l6) * ET.ty(l4) * ET.ry()</p></li>
<li><p>ET.tz(l5) * ET.rz() * ET.ry() * ET.rz()</p></li>
</ul>
</div></blockquote>
<p>end{Code}
begin{Code}
&gt;&gt;&gt; robot = SerialLink(ETS String)
end{Code}
and can represent single-branched robots with any combination of revolute and prismatic joints.</p>
<p>subsubsection{ERobot: rigid-body tree and URDF import}
The final approach is to an import a URDF file.  The Toolbox includes a parser with built-in xacro processor
which makes many models from the ROS universe available.</p>
<p>More complex models such as for Panda or Puma are defined by classes but built this way</p>
<p>begin{Code}
&gt;&gt;&gt; panda = Panda()
end{Code}</p>
<p>Forward kinematics is simply
begin{Code}
&gt;&gt;&gt; T = robot.fkine(panda.qz)
end{Code}</p>
<p>where known poses are defined by properties such panda.qz.
For branched robots, with multipe end-effectors,  the name of the frame of interest must be provided.</p>
<p>This pose can be visualized by
begin{Code}
&gt;&gt;&gt; panda.plot(qz)
end{Code}
which produces the 3-D plot shown in Figure ref{fig:noodle}.</p>
<p>and inverse kinematic is</p>
<p>begin{Code}
&gt;&gt;&gt; q = panda.ikine(T)
end{Code}</p>
</div>
</div>
<div class="section" id="trajectories">
<h2>Trajectories<a class="headerlink" href="#trajectories" title="Permalink to this headline">¬∂</a></h2>
<p>A joint-spae trajectory for the Puma robot from its zero angle
pose to the upright (or READY) pose in 100 steps is</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>where code{puma.qr} is an example of a named joint configuration.
code{traj} is named tuple with elements code{q}$=vec{q}_k$, code{qd}$=dvec{q}_k$ and code{qdd}$=ddvec{q}_k$.
Each element is an array with one row per time step, and each row a joint angle vector.
The trajectory is a fifth order polynomial which has continuous jerk.
By default, the initial and final velocities are zero, but these may be specified by additional
arguments.</p>
<p>Straight line (Cartesian) paths can be generated in a similar way between
two points specified by a pair of poses in SE{3}</p>
<p>The resulting trajectory, code{Ts}, is an code{SE3} instance with 200 values.
For both trajectory types the number of steps is given by an integer argument or the length of a
passed time vector.</p>
<p>Inverse kinematics can then be applied to determine the corresponding
joint angle motion using</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>where code{qs} is is an array of joint coordinates, one row per timestep.
In this case the starting
joint coordinates for each inverse kinematic solution
is taken as the result of the previous solution.</p>
<div class="section" id="symbolic-manipulation">
<h3>Symbolic manipulation<a class="headerlink" href="#symbolic-manipulation" title="Permalink to this headline">¬∂</a></h3>
<p>As mentioned earlier, the Toolbox supports SymPy. For example:</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">NameError</span>: <span class="n">name &#39;rpy2r&#39; is not defined</span>
</pre></div>
</div>
<p>The capability extends to forward kinematics</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>If we display the value of var{puma} we see that the $alpha_j$ values are now displayed in red to indicate that they are symbolic constants.  The x-coordinate of the end-effector is</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>SymPy allows any expression to be converted to runnable code in a variety of languages including C, Python and Octave/MATLAB.</p>
</div>
<div class="section" id="differential-kinematics">
<h3>Differential kinematics<a class="headerlink" href="#differential-kinematics" title="Permalink to this headline">¬∂</a></h3>
<p>The Toolbox computes Jacobians:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="n">puma</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">J</span> <span class="o">=</span> <span class="n">puma</span><span class="o">.</span><span class="n">jacobe</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>in the base or end-effector frames respectively, as NumPy arrays.
At a singular configuration</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span><span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;input&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">&lt;module&gt;</span>
<span class="gr">NameError</span>: <span class="n">name &#39;jsingu&#39; is not defined</span>
</pre></div>
</div>
<p>Jacobians can also be computed for symbolic joint variables as for forward kinematics above.</p>
<p>For var{ERobot} instances we can also compute the Hessians:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">puma</span><span class="o">.</span><span class="n">hessian0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">puma</span><span class="o">.</span><span class="n">hessiane</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>in the base or end-effector frames respectively, as 3D NumPy arrays in $mathbb{R}^{6 times n times n}$.</p>
<p>For all robot classes we can compute manipulability</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>for the Yoshikawacite{yoshikawa1984analysis} and Asadacite{asada1983geometrical}
% measures respectively, and
measures, and</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>is the Yoshikawa measure computed for just the task space translational degrees
of freedom.
For var{ERobot} instances we can also compute the manipulability
Jacobian
begin{Code}
&gt;&gt;&gt; Jm = puma.manipm(q, J, H)
end{Code}
such that $dot{m} = mat{J}_m(vec{q}) dvec{q}$.</p>
<p>%%%%%%%%%%%%%% DYNAMICS
Dynamics
‚Äî‚Äî‚Äì</p>
<p>The new Toolbox supports several approaches to computing dynamics.
For models defined using standard or modified DH notation we use a classical version of the recursive Newton-Euler~cite{Armstrong79}
algorithm implemented in Python or Cfootnote{The same code as used by RTB-M is called directly from Python, and does not use NumPy.}.
For example, the inverse dynamics
begin{Code}
&gt;&gt;&gt; tau = puma.rne(puma.qn, np.zeros((6,)), np.zeros((6,)))
end{Code}
is the gravity torque for the robot in the configuration var{qn}.</p>
<p>Inertia, Coriolis/centripetal and gravity terms are computed by</p>
<div class="highlight-pycon notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Jpuma</span><span class="o">.</span><span class="n">inertia</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">puma</span><span class="o">.</span><span class="n">coriolis</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">qd</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">puma</span><span class="o">.</span><span class="n">gravload</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
</pre></div>
</div>
<p>respectively, using the method of
cite{Walker82} from the inverse dynamics.  These values include the effect of motor inertia and friction.</p>
<p>Forward dynamics are given by
begin{Code}
&gt;&gt;&gt; qdd = puma.accel(q, tau, qd)
end{Code}
which we can integrate over time
begin{Code}
&gt;&gt;&gt; q = puma.fdyn(5, q0, mycontrol, ‚Ä¶)
end{Code}
uses an RK45 numerical integration from the SciPy package to solve for the joint trajectory code{q} given the
control function called as
begin{Code}</p>
<blockquote>
<div><p>tau = mycontrol(robot, t, q, qd, <a href="#id10"><span class="problematic" id="id11">**</span></a>args)</p>
</div></blockquote>
<p>end{Code}</p>
<p>The fast C implementation is not capable of symbolic operation so a Python version of RNE code{rne_python} has been
implemented as well.  For a 6- or 7-DoF manipulator the torque expressions have thousands of terms yet are computed in less than a second. However, subsequent expression manipulation is slow, and the best strategy is to eliminate the least significant terms and this typically gets the expression for the first joint to a hundred or so terms which is quite manageable.
This is an area of active work, as is the automatic generation of efficient run-time
code for manipulator dynamics.</p>
<p>For the Puma560 robot the C version of inverse dynamics takes 23unit{mu s} while the
Python version takes 1.5unit{ms} ($65times$ slower).  With symbolic operands it takes 170unit{ms} ($113times$ slower) to produce the unsimplified torque expressions.</p>
<p>For all robots there is also an implementation of Featherstone‚Äôs spatial vector method, code{rne_spatial}, and SMTB-P provides a set of classes for
spatial velocity, acceleration, momentum, force and inertia.</p>
<hr class="docutils" />
<p>section{New capability}
There are several areas of innovation compared to the MATLAB version of the Toolbox.</p>
<p>subsection{Branched mechanisms}
The RTB-M code{SerialLink} class had no option to express branching.
In RTB-P the equivalent class is code{DHRobot} is similarly limited, but a new class code{ERobot} is more general and allows for branching (but not closed
kinematic loops).
The robot is described by a set of code{ELink} objects, each of which points to its parent link.
The code{ERobot} has references to the root and leaf code{ELink}s.
This structure closely mirrors the URDF representation, allowing for easy import of URDF models.</p>
<p>subsection{Collision checking}
RTB-M had a simple, contributed but unsupported, collision checking capability.
This is dramatically improved in the Python version using using PyBullet~cite{py3} which supports primitive shapes such as Cylinders, Spheres and Boxes as well as mesh objects.
Every robot link has a collision shape in addition to the shape used for rendering.
We can conveniently perform collision checks between links as well as between whole robots, discrete links, and objects in the world. For example a $1 times 1 times 1$ box
centered at $(1,0,0)$ can be tested against all, or just one link, of the robot by
%
begin{Code}
&gt;&gt;&gt; panda = rtb.models.Panda()
&gt;&gt;&gt; obstacle = rtb.Box([1, 1, 1], SE3(1, 0, 0))
&gt;&gt;&gt; iscollision = panda.collided(obstacle) # boolean
&gt;&gt;&gt; iscollision = panda.links[0].collided(obstacle)
end{Code}
%
Additionally, we can compute the minimum Euclidean distance between whole robots, discrete links, or objects and get the points in the world frame which construct this line.
%
begin{Code}
&gt;&gt;&gt; d, p1, p2 = panda.closest_point(obstacle)
&gt;&gt;&gt; d, p1, p2 = panda.links[0].closest_point(obstacle)
end{Code}
which returns the distance and the coordinates of the closest points on the two bodies.</p>
<p>% Bullet is a fast and mature package which we found gave better results than FCLcite{}
% but found that closest points between polyhedra snapped to vertices rather than the actual closest points on
% faces.</p>
<p>subsection{Interfaces}
RTB-M could only animate a robot in a figure, and there was limited but not-well-supported ability to interface to V-REP
and a physical robot.
The Python version supports a simple, but universal API to a robot
inspired by the simplicity and expressiveness of the OpenAI Gym API cite{gym} which was designed as a toolkit for developing and comparing reinforcement learning algorithms.
Whether simulating a robot or controlling a real physical robot, the API operates in the same manner.
% providing users with a common interface which is not found amoung other robotics packages.</p>
<p>By default the Toolbox behaves like the MATLAB version with a plot method
begin{Code}
&gt;&gt;&gt; puma.plot(q)
end{Code}
which will plot the robot at the specified joint configurmation, or animate it if code{q} is an $m times 6$ matrix, using
the default code{PyPlot} backend which draws a <a href="#id12"><span class="problematic" id="id13">``</span></a>noodle robot‚Äô‚Äô using matplotlib similar to that
shown in Figure ref{fig:noodle}.</p>
<p>The more general solution, and what is implemented inside code{plot} in the example above, is
begin{Code}
&gt;&gt;&gt; pyplot = roboticstoolbox.backends.PyPlot()
&gt;&gt;&gt; pyplot.launch()
&gt;&gt;&gt; pyplot.add(puma)
&gt;&gt;&gt; puma.q = q
&gt;&gt;&gt; puma.step()
end{Code}</p>
<p>This makes it possible to animate multiple robots in the one graphical window, or the one robot in various environments either graphical
or real.</p>
<p>The VPython backend, see Fig. ref{fig:vpython}, provides browser-based 3D graphics based on WebGL.  This is advantageous for displaying on mobile
devices.  Swift, see Fig. ref{fig:ur-lineup}, is an Electron app that uses three.js to provide high-quality 3D animations.
It can produce vivid 3D effects using anaglyphs viewed with colored glasses, and
we also adapted it to work with a Looking Glass light-field (holographic) displayfootnote{url{https://lookingglassfactory.com}} for
glasses-free 3D viewing.
Animations can be recorded as MP4 files or animated GIF files which are useful for inclusion in GitHub markdown documents.</p>
<p>section{Code engineering}
The code is implemented in Python $ge 3.6$ and all code is hosted on GitHub and unit-testing is performed using GitHub-actions.
Test coverage is uploaded to code{codecov.io} for visualization and trending, and we use code{lgtm.com} to perform
automated code review.
The code is documented with ReStructured Text format docstrings which provides powerful markup including cross-referencing, equations, class inheritance diagrams and figures ‚Äì all of which is converted to HTML documentation whenever a change is pushed, and this is accessible via GitHub pages.
Issues can be reported via GitHub issues or patches submitted as pull requests.</p>
<p>RTB-P, and its dependencies, can be installed simply by
begin{Code}
$ pip install roboticstoolbox-python
end{Code}
which includes basic visualization using matplotlib.
Options such as code{vpython} can be used to specify additional dependencies to be installed.
The Toolbox adopts a <a href="#id14"><span class="problematic" id="id15">``</span></a>when needed‚Äô‚Äô approach to many dependencies and will only attempt
to import them if the user attempts to exploit a particular functionality.  If the dependency is not installed a warning provides instructions on how to install them using pip and/or npm.
More details are given on the project home page.footnote{url{<a class="reference external" href="https://github.com/petercorke/robotics-toolbox-python">https://github.com/petercorke/robotics-toolbox-python</a>}}
This applies to the visualizers Vpython and Swift, as well as pybullet and ROS.
The Toolbox provides capability to import URDF-xacro files without ROS.
The backend architecture allows a user to connect to a ROS environment if required, and only then does ROS have to be
installed.</p>
<p>section{Conclusion}
This paper has introduced and demonstrated in tutorial form the principle features of the Robotics
Toolbox for Python which runs on Mac, Windows and Linux.% using Python 3.6 or better.
The code is free and open, and released under the MIT licence.
It provides many of the essential tools necessary for
robotic manipulator modelling, simulation and  control which is essential for robotics education  and research.
It is familiar yet new, and we hope it will serve the community well for the next 25 years.</p>
<p>Currently under development are backend interfaces for CoppeliaSim, Dynamixel servo chains, and ROS;
symbolic dynamics, simplification and code generation; mobile robotics motion models, planners, EKF localization, map making and SLAM; and a minimalist block-diagram simulation toolfootnote{url{<a class="reference external" href="https://github.com/petercorke/bdsim">https://github.com/petercorke/bdsim</a>}}.</p>
<p>clearpage</p>
<p>bibliographystyle{IEEEtran}</p>
<p>% bibliography{IEEEabrv, ref} % For normal
bibliography{publist,book,refs} % For overleaf</p>
<p>end{document}</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="arm.html" class="btn btn-neutral float-right" title="Manipulator arms" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="index.html" class="btn btn-neutral float-left" title="Robotics Toolbox for Python" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Jesse Haviland and Peter Corke
      <span class="lastupdated">
        Last updated on 05-Nov-2020.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'G-11Q6WJM565', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>