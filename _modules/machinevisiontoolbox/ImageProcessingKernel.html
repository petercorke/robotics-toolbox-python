

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>machinevisiontoolbox.ImageProcessingKernel &mdash; Machine Vision Toolbox 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> Machine Vision Toolbox
          

          
            
            <img src="../../_static/VisionToolboxLogo_CircBlack.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../image.html">Image processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../color.html">Color</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Machine Vision Toolbox</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>machinevisiontoolbox.ImageProcessingKernel</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for machinevisiontoolbox.ImageProcessingKernel</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">spatialmath.base.argcheck</span> <span class="k">as</span> <span class="nn">argcheck</span>
<span class="kn">import</span> <span class="nn">cv2</span> <span class="k">as</span> <span class="nn">cv</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sp</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>


<span class="k">class</span> <span class="nc">ImageProcessingKernelMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Image processing kernel operations on the Image class</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">kgauss</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">hw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gaussian kernel</span>

<span class="sd">        :param sigma: standard deviation of Gaussian kernel</span>
<span class="sd">        :type sigma: float</span>
<span class="sd">        :param hw: width of the kernel</span>
<span class="sd">        :type hw: integer</span>
<span class="sd">        :return k: kernel</span>
<span class="sd">        :rtype: numpy array (N,H)</span>

<span class="sd">        - ``IM.kgauss(sigma)`` is a 2-dimensional Gaussian kernel of standard</span>
<span class="sd">          deviation ``sigma``, and centred within the matrix ``k`` whose</span>
<span class="sd">          half-width is ``hw=2*sigma`` and ``w=2*hw+1``.</span>

<span class="sd">        - ``IM.kgauss(sigma, hw)`` as above but the half-width ``hw`` is</span>
<span class="sd">          specified.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - The volume under the Gaussian kernel is one.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># make sure sigma, w are valid input</span>
        <span class="k">if</span> <span class="n">hw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="n">wi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">wi</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># area under the curve should be 1, but the discrete case is only</span>
        <span class="c1"># an approximation</span>
        <span class="k">return</span> <span class="n">m</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">klaplace</span><span class="p">():</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Laplacian kernel</span>

<span class="sd">        :return k: kernel</span>
<span class="sd">        :rtype: numpy array (3,3)</span>

<span class="sd">        - ``IM.klaplace()`` is the Laplacian kernel:</span>

<span class="sd">        .. math::</span>

<span class="sd">            K = \begin{bmatrix}</span>
<span class="sd">                0 &amp; 1 &amp; 0 \\</span>
<span class="sd">                1 &amp; -4 &amp; 1 \\</span>
<span class="sd">                0 &amp; 1 &amp; 0</span>
<span class="sd">                \end{bmatrix}</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - This kernel has an isotropic response to image gradient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">ksobel</span><span class="p">():</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sobel edge detector</span>

<span class="sd">        :return k: kernel</span>
<span class="sd">        :rtype: numpy array (3,3)</span>

<span class="sd">        - ``IM.ksobel()`` is the Sobel x-derivative kernel:</span>

<span class="sd">        .. math::</span>

<span class="sd">            K = \frac{1}{8} \begin{bmatrix}</span>
<span class="sd">                1 &amp; 0 &amp; -1 \\</span>
<span class="sd">                2 &amp; 0 &amp; -2 \\</span>
<span class="sd">                1 &amp; 0 &amp; -1</span>
<span class="sd">                \end{bmatrix}</span>

<span class="sd">        .. note::</span>

<span class="sd">            - This kernel is an effective vertical-edge detector</span>
<span class="sd">            - The y-derivative (horizontal-edge) kernel is K&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]])</span> <span class="o">/</span> <span class="mf">8.0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">kdog</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">sigma2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Difference of Gaussians kernel</span>

<span class="sd">        :param sigma1: standard deviation of first Gaussian kernel</span>
<span class="sd">        :type sigma1: float</span>
<span class="sd">        :param sigma2: standard deviation of second Gaussian kernel</span>
<span class="sd">        :type sigma2: float</span>
<span class="sd">        :param hw: half-width of Gaussian kernel</span>
<span class="sd">        :type hw: integer</span>
<span class="sd">        :return k: kernel</span>
<span class="sd">        :rtype: numpy array</span>

<span class="sd">        - ``IM.kdog(sigma1)`` is a 2-dimensional difference of Gaussian kernel</span>
<span class="sd">          equal to ``kgauss(sigma1) - kgauss(sigma2)``, where ``sigma1`` &gt;</span>
<span class="sd">          ``sigma2. By default, ``sigma2 = 1.6 * sigma1``.  The kernel is</span>
<span class="sd">          centred within the matrix ``k`` whose half-width ``hw = 3xsigma1``</span>
<span class="sd">          and full width of the kernel is ``2xhw+1``.</span>

<span class="sd">        - ``IM.kdog(sigma1, sigma2)`` as above but sigma2 is specified</span>
<span class="sd">          directly.</span>

<span class="sd">        - ``IM.kdog(sigma1, sigma2, hw)`` as above but the kernel half-width is</span>
<span class="sd">          specified</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - This kernel is similar to the Laplacian of Gaussian and is often</span>
<span class="sd">              used as an efficient approximation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># sigma1 &gt; sigma2</span>
        <span class="k">if</span> <span class="n">sigma2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sigma2</span> <span class="o">=</span> <span class="mf">1.6</span> <span class="o">*</span> <span class="n">sigma1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sigma2</span> <span class="o">&gt;</span> <span class="n">sigma1</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">sigma1</span>
                <span class="n">sigma1</span> <span class="o">=</span> <span class="n">sigma2</span>
                <span class="n">sigma2</span> <span class="o">=</span> <span class="n">t</span>

        <span class="c1"># thus, sigma2 &gt; sigma1</span>
        <span class="k">if</span> <span class="n">hw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">sigma1</span><span class="p">)</span>

        <span class="n">m1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgauss</span><span class="p">(</span><span class="n">sigma1</span><span class="p">,</span> <span class="n">hw</span><span class="p">)</span>  <span class="c1"># thin kernel</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgauss</span><span class="p">(</span><span class="n">sigma2</span><span class="p">,</span> <span class="n">hw</span><span class="p">)</span>  <span class="c1"># wide kernel</span>

        <span class="k">return</span> <span class="n">m2</span> <span class="o">-</span> <span class="n">m1</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">klog</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">hw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Laplacian of Gaussian kernel</span>

<span class="sd">        :param sigma1: standard deviation of first Gaussian kernel</span>
<span class="sd">        :type sigma1: float</span>
<span class="sd">        :param hw: half-width of kernel</span>
<span class="sd">        :type hw: integer</span>
<span class="sd">        :return k: kernel</span>
<span class="sd">        :rtype: numpy array (2 * 3 * sigma + 1, 2 * 3 * sigma + 1)</span>

<span class="sd">        - ``IM.klog(sigma)`` is a 2-dimensional Laplacian of Gaussian kernel of</span>
<span class="sd">          width (standard deviation) sigma and centred within the matrix ``k``</span>
<span class="sd">          whose half-width is ``hw=3xsigma``, and ``w=2xhw+1``.</span>

<span class="sd">        - ``IM.klog(sigma, hw)`` as above but the half-width ``w`` is</span>
<span class="sd">          specified.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">hw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span>
        <span class="n">wi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">wi</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>

        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mf">4.0</span><span class="p">)</span> <span class="o">*</span> \
            <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">kdgauss</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">hw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Derivative of Gaussian kernel</span>

<span class="sd">        :param sigma1: standard deviation of first Gaussian kernel</span>
<span class="sd">        :type sigma1: float</span>
<span class="sd">        :param hw: half-width of kernel</span>
<span class="sd">        :type hw: integer</span>
<span class="sd">        :return k: kernel</span>
<span class="sd">        :rtype: numpy array (2 * 3 * sigma + 1, 2 * 3 * sigma + 1)</span>

<span class="sd">        - ``IM.kdgauss(sigma)`` is a 2-dimensional derivative of Gaussian</span>
<span class="sd">          kernel ``(w,w)`` of width (standard deviation) sigma and centred</span>
<span class="sd">          within the matrix ``k`` whose half-width ``hw = 3xsigma`` and</span>
<span class="sd">          ``w=2xhw+1``.</span>

<span class="sd">        - ``IM.kdgauss(sigma, hw)`` as above but the half-width is explictly</span>
<span class="sd">          specified.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - This kernel is the horizontal derivative of the Gaussian, dG/dx.</span>
<span class="sd">            - The vertical derivative, dG/dy, is k&#39;.</span>
<span class="sd">            - This kernel is an effective edge detector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">hw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">3.0</span> <span class="o">*</span> <span class="n">sigma</span><span class="p">)</span>

        <span class="n">wi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">hw</span><span class="p">,</span> <span class="n">hw</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">wi</span><span class="p">,</span> <span class="n">wi</span><span class="p">)</span>

        <span class="k">return</span> <span class="o">-</span><span class="n">x</span> <span class="o">/</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">sigma</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">kcircle</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">hw</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Circular structuring element</span>

<span class="sd">        :param r: radius of circle structuring element, or 2-vector (see below)</span>
<span class="sd">        :type r: float, 2-tuple or 2-element vector of floats</span>
<span class="sd">        :param hw: half-width of kernel</span>
<span class="sd">        :type hw: integer</span>
<span class="sd">        :return k: kernel</span>
<span class="sd">        :rtype: numpy array (2 * 3 * sigma + 1, 2 * 3 * sigma + 1)</span>

<span class="sd">        - ``IM.kcircle(r)`` is a square matrix ``(w,w)`` where ``w=2r+1`` of</span>
<span class="sd">          zeros with a maximal centred circular region of radius ``r`` pixels</span>
<span class="sd">          set to one.</span>

<span class="sd">        - ``IM.kcircle(r,w)`` as above but the dimension of the kernel is</span>
<span class="sd">          explicitly specified.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - If ``r`` is a 2-element vector the result is an annulus of ones,</span>
<span class="sd">              and the two numbers are interpretted as inner and outer radii.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check valid input:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>  <span class="c1"># r.shape[1] &gt; 1:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">getvector</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">rmax</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">rmin</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rmax</span> <span class="o">=</span> <span class="n">r</span>

        <span class="k">if</span> <span class="n">hw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">hw</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">hw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">rmax</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">w</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">w</span><span class="p">)))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">w</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kcircle</span><span class="p">(</span><span class="n">rmax</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">kcircle</span><span class="p">(</span><span class="n">rmin</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">-</span> <span class="n">c</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">ll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">((</span><span class="n">X</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">Y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">r</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">s</span><span class="p">[</span><span class="n">ll</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">hw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">optmode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">optboundary</span><span class="o">=</span><span class="s1">&#39;fill&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth image</span>

<span class="sd">        :param sigma: standard deviation of the Gaussian kernel</span>
<span class="sd">        :type sigma: float</span>
<span class="sd">        :param hw: half-width of the kernel</span>
<span class="sd">        :type hw: float</span>
<span class="sd">        :param opt: convolution options np.convolve (see below)</span>
<span class="sd">        :type opt: string</span>
<span class="sd">        :return out: Image with smoothed image pixels</span>
<span class="sd">        :rtype: Image instance</span>

<span class="sd">        - ``IM.smooth(sigma)`` is the image after convolution with a Gaussian</span>
<span class="sd">          kernel of standard deviation ``sigma``</span>

<span class="sd">        - ``IM.smooth(sigma, hw)`` as above with kernel half-width ``hw``.</span>

<span class="sd">        - ``IM.smooth(sigma, opt)`` as above with options passed to np.convolve</span>

<span class="sd">        :options:</span>

<span class="sd">            - &#39;full&#39;    returns the full 2-D convolution (default)</span>
<span class="sd">            - &#39;same&#39;    returns OUT the same size as IM</span>
<span class="sd">            - &#39;valid&#39;   returns  the valid pixels only, those where the kernel</span>
<span class="sd">              does not exceed the bounds of the image.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - By default (option &#39;full&#39;) the returned image is larger than the</span>
<span class="sd">              passed image.</span>
<span class="sd">            - Smooths all planes of the input image.</span>
<span class="sd">            - The Gaussian kernel has a unit volume.</span>
<span class="sd">            - If input image is integer it is converted to float, convolved,</span>
<span class="sd">              then converted back to integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="s1">&#39;sigma must be a scalar&#39;</span><span class="p">)</span>

        <span class="n">modeopt</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;full&#39;</span><span class="p">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span>
            <span class="s1">&#39;valid&#39;</span><span class="p">:</span> <span class="s1">&#39;valid&#39;</span><span class="p">,</span>
            <span class="s1">&#39;same&#39;</span><span class="p">:</span> <span class="s1">&#39;same&#39;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">optmode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modeopt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">optmode</span><span class="p">,</span> <span class="s1">&#39;opt is not a valid option&#39;</span><span class="p">)</span>

        <span class="n">boundaryopt</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fill&#39;</span><span class="p">:</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span>
            <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="s1">&#39;wrap&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reflect&#39;</span><span class="p">:</span> <span class="s1">&#39;symm&#39;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">optboundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">boundaryopt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">optboundary</span><span class="p">,</span> <span class="s1">&#39;opt is not a valid option&#39;</span><span class="p">)</span>

        <span class="n">is_int</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">is_int</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">float</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="c1"># make the smoothing kernel</span>
        <span class="n">K</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kgauss</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">hw</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
            <span class="c1"># could replace this with a nested list comprehension</span>

            <span class="n">ims</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">img</span><span class="p">:</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]),</span>
                                                 <span class="n">K</span><span class="p">,</span>
                                                 <span class="n">mode</span><span class="o">=</span><span class="n">modeopt</span><span class="p">[</span><span class="n">optmode</span><span class="p">],</span>
                                                 <span class="n">boundary</span><span class="o">=</span><span class="n">boundaryopt</span><span class="p">[</span>
                                                     <span class="n">optboundary</span><span class="p">])</span>
                              <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">numchannels</span><span class="p">)])</span>
                <span class="n">ims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">img</span><span class="o">.</span><span class="n">iscolor</span><span class="p">:</span>
            <span class="n">ims</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">img</span><span class="p">:</span>
                <span class="n">ims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                                             <span class="n">K</span><span class="p">,</span>
                                             <span class="n">mode</span><span class="o">=</span><span class="n">modeopt</span><span class="p">[</span><span class="n">optmode</span><span class="p">],</span>
                                             <span class="n">boundary</span><span class="o">=</span><span class="n">boundaryopt</span><span class="p">[</span>
                                                 <span class="n">optboundary</span><span class="p">]))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iscolor</span><span class="p">,</span> <span class="s1">&#39;bad value for iscolor&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_int</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span><span class="o">.</span><span class="n">int</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">ims</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sum of absolute differences</span>

<span class="sd">        :param im2: image 2</span>
<span class="sd">        :type im2: numpy array</span>
<span class="sd">        :return out: sad</span>
<span class="sd">        :rtype out: scalar</span>

<span class="sd">        - ``IM.sad(im2)`` is the sum of absolute differences between the two</span>
<span class="sd">          equally sized image patches of image and ``im2``. The result is a</span>
<span class="sd">          scalar that indicates image similarity, a value of 0 indicates</span>
<span class="sd">          identical pixel patterns and is increasingly positive as image</span>
<span class="sd">          dissimilarity increases.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="s1">&#39;im2 shape is not equal to self&#39;</span><span class="p">)</span>

        <span class="c1"># out = []</span>
        <span class="c1"># for im in self:</span>
            <span class="c1"># m = np.abs(im.image - im2.image)</span>
            <span class="c1"># out.append(np.sum(m))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">im2</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">ssd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sum of squared differences</span>

<span class="sd">        :param im2: image 2</span>
<span class="sd">        :type im2: numpy array</span>
<span class="sd">        :return out: ssd</span>
<span class="sd">        :rtype out: scalar</span>

<span class="sd">        - ``IM.ssd(im2)`` is the sum of squared differences between the two</span>
<span class="sd">          equally sized image patches image and ``im2``.  The result M is a</span>
<span class="sd">          scalar that indicates image similarity, a value of 0 indicates</span>
<span class="sd">          identical pixel patterns and is increasingly positive as image</span>
<span class="sd">          dissimilarity increases.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="s1">&#39;im2 shape is not equal to im1&#39;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">im2</span><span class="o">.</span><span class="n">image</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ncc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalised cross correlation</span>

<span class="sd">        :param im2: image 2</span>
<span class="sd">        :type im2: numpy array</span>
<span class="sd">        :return out: ncc</span>
<span class="sd">        :rtype out: scalar</span>

<span class="sd">        - ``IM.ncc(im2)`` is the normalized cross-correlation between the two</span>
<span class="sd">          equally sized image patches image and ``im2``. The result is a scalar</span>
<span class="sd">          in the interval -1 (non match) to 1 (perfect match) that indicates</span>
<span class="sd">          similarity.</span>

<span class="sd">        .. note::</span>

<span class="sd">            - A value of 1 indicates identical pixel patterns.</span>
<span class="sd">            - The ``ncc`` similarity measure is invariant to scale changes in</span>
<span class="sd">              image intensity.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="s1">&#39;im2 shape is not equal to im1&#39;</span><span class="p">)</span>

        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">im2</span><span class="o">.</span><span class="n">image</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">denom</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">*</span> <span class="n">im2</span><span class="o">.</span><span class="n">image</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>

    <span class="k">def</span> <span class="nf">zsad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Zero-mean sum of absolute differences</span>

<span class="sd">        :param im2: image 2</span>
<span class="sd">        :type im2: numpy array</span>
<span class="sd">        :return out: zsad</span>
<span class="sd">        :rtype out: scalar</span>

<span class="sd">        - ``IM.zsad(im2)`` is the zero-mean sum of absolute differences between</span>
<span class="sd">          the two equally sized image patches image and ``im2``. The result is</span>
<span class="sd">          a scalar that indicates image similarity, a value of 0 indicates</span>
<span class="sd">          identical pixel patterns and is increasingly positive as image</span>
<span class="sd">          dissimilarity increases.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - The ``zsad`` similarity measure is invariant to changes in image</span>
<span class="sd">            brightness offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="s1">&#39;im2 shape is not equal to im1&#39;</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">image2</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">im2</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">image</span> <span class="o">-</span> <span class="n">image2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zssd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Zero-mean sum of squared differences</span>

<span class="sd">        :param im2: image 2</span>
<span class="sd">        :type im2: numpy array</span>
<span class="sd">        :return out: zssd</span>
<span class="sd">        :rtype out: scalar</span>

<span class="sd">        - ``IM.zssd(im1, im2)`` is the zero-mean sum of squared differences</span>
<span class="sd">          between the two equally sized image patches image and ``im2``.  The</span>
<span class="sd">          result is a scalar that indicates image similarity, a value of 0</span>
<span class="sd">          indicates identical pixel patterns and is increasingly positive as</span>
<span class="sd">          image dissimilarity increases.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - The ``zssd`` similarity measure is invariant to changes in image</span>
<span class="sd">              brightness offset.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="s1">&#39;im2 shape is not equal to im1&#39;</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">image2</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">im2</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">image</span> <span class="o">-</span> <span class="n">image2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">zncc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">im2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Zero-mean normalized cross correlation</span>

<span class="sd">        :param im2: image 2 :type im2: numpy array :return out: zncc :rtype</span>
<span class="sd">        out: scalar</span>

<span class="sd">        - ``IM.zncc(im2)`` is the zero-mean normalized cross-correlation</span>
<span class="sd">          between the two equally sized image patches image and ``im2``.  The</span>
<span class="sd">          result is a scalar in the interval -1 to 1 that indicates similarity.</span>
<span class="sd">          A value of 1 indicates identical pixel patterns.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - The ``zncc`` similarity measure is invariant to affine changes</span>
<span class="sd">              in image intensity (brightness offset and scale).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="s1">&#39;im2 shape is not equal to im1&#39;</span><span class="p">)</span>

        <span class="n">image</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">image2</span> <span class="o">=</span> <span class="n">im2</span><span class="o">.</span><span class="n">image</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">im2</span><span class="o">.</span><span class="n">image</span><span class="p">)</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">image2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))))</span>

        <span class="k">if</span> <span class="n">denom</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">image</span> <span class="o">*</span> <span class="n">image2</span><span class="p">)</span> <span class="o">/</span> <span class="n">denom</span>

    <span class="k">def</span> <span class="nf">pyramid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pyramidal image decomposition</span>

<span class="sd">        :param sigma: standard deviation of Gaussian kernel</span>
<span class="sd">        :type sigma: float</span>
<span class="sd">        :param N: number of pyramid levels to be computed</span>
<span class="sd">        :type N: int</span>
<span class="sd">        :return pyrimlist: list of Images for each pyramid level computed</span>
<span class="sd">        :rtype pyrimlist: list</span>

<span class="sd">        - ``IM.pyramid()`` is a pyramid decomposition of image using Gaussian</span>
<span class="sd">          smoothing with standard deviation of 1. The return is a list array of</span>
<span class="sd">          images each one having dimensions half that of the previous image.</span>
<span class="sd">          The pyramid is computed down to a non-halvable image size.</span>

<span class="sd">        - ``IM.pyramid(sigma)`` as above but the Gaussian standard deviation is</span>
<span class="sd">          ``sigma``.</span>

<span class="sd">        - ``IM.pyramid(sigma, N)`` as above but only ``N`` levels of the</span>
<span class="sd">          pyramid are computed.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Converts a color image to greyscale.</span>
<span class="sd">            - Works for greyscale images only.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check inputs, greyscale only</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mono</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">sigma</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="s1">&#39;sigma must be a scalar&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">argcheck</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span><span class="n">N</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="p">(</span><span class="n">N</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s1">&#39;N must be a scalar and </span><span class="se">\</span>
<span class="s1">                    0 &lt;= N &lt;= max(im.shape)&#39;</span><span class="p">)</span>

        <span class="c1"># TODO options to accept different border types,</span>
        <span class="c1"># note that the Matlab implementation is hard-coded to &#39;same&#39;</span>

        <span class="c1"># return cv.buildPyramid(im, N, borderType=cv.BORDER_REPLICATE)</span>
        <span class="c1"># Python version does not seem to be implemented</span>

        <span class="c1"># list comprehension approach</span>
        <span class="c1"># TODO pyr = [cv.pyrdown(inputs(i)) for i in range(N) if conditional]</span>

        <span class="n">impyr</span> <span class="o">=</span> <span class="n">im</span><span class="o">.</span><span class="n">image</span>
        <span class="n">pyr</span> <span class="o">=</span> <span class="p">[</span><span class="n">impyr</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">impyr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">impyr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">impyr</span> <span class="o">=</span> <span class="n">cv</span><span class="o">.</span><span class="n">pyrDown</span><span class="p">(</span><span class="n">impyr</span><span class="p">,</span> <span class="n">borderType</span><span class="o">=</span><span class="n">cv</span><span class="o">.</span><span class="n">BORDER_REPLICATE</span><span class="p">)</span>
            <span class="n">pyr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">impyr</span><span class="p">)</span>

        <span class="c1"># output list of Image objects</span>
        <span class="n">pyrimlist</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pyr</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">pyrimlist</span>

    <span class="k">def</span> <span class="nf">window</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">se</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">opt</span><span class="o">=</span><span class="s1">&#39;border&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generalized spatial operator</span>

<span class="sd">        :param se: structuring element</span>
<span class="sd">        :type se: numpy array</span>
<span class="sd">        :param func: function to operate</span>
<span class="sd">        :type funct: reference to a callable function</span>
<span class="sd">        :param opt: border option</span>
<span class="sd">        :type opt: string</span>
<span class="sd">        :return out: Image after function has operated on every pixel by func</span>
<span class="sd">        :rtype out: Image instance</span>

<span class="sd">        - ``IM.window(se, func)`` is an image where each pixel is the result of</span>
<span class="sd">          applying the function ``func`` to a neighbourhood centred on the</span>
<span class="sd">          corresponding pixel in image. The neighbourhood is defined by the</span>
<span class="sd">          size of the structuring element ``se`` which should have odd side</span>
<span class="sd">          lengths. The elements in the neighbourhood corresponding to non-zero</span>
<span class="sd">          elements in ``se`` are packed into a vector (in column order from top</span>
<span class="sd">          left) and passed to the specified callable function ``func``. The</span>
<span class="sd">          return value of ``func`` becomes the corresponding pixel value.</span>

<span class="sd">        - ``IM.window(se, func, opt)`` as above but performance of edge pixels</span>
<span class="sd">          can be controlled.</span>

<span class="sd">        :options:</span>

<span class="sd">            - &#39;replicate&#39;     the border value is replicated (default)</span>
<span class="sd">            - &#39;none&#39;          pixels beyond the border are not included in the</span>
<span class="sd">              window</span>
<span class="sd">            - &#39;trim&#39;          output is not computed for pixels where the</span>
<span class="sd">              structuring element crosses the image border, hence output image</span>
<span class="sd">              has reduced dimensions TODO</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - The structuring element should have an odd side length.</span>
<span class="sd">            - Is slow since the function ``func`` must be invoked once for</span>
<span class="sd">              every output pixel.</span>
<span class="sd">            - The input can be logical, uint8, uint16, float or double, the</span>
<span class="sd">              output is always double</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># replace window&#39;s mex function with scipy&#39;s ndimage.generic_filter</span>

        <span class="c1"># border options:</span>
        <span class="n">edgeopt</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;border&#39;</span><span class="p">:</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
            <span class="s1">&#39;none&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
            <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="s1">&#39;wrap&#39;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">opt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edgeopt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">opt</span><span class="p">,</span> <span class="s1">&#39;opt is not a valid edge option&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;func not callable&#39;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sp</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">generic_filter</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                                                 <span class="n">func</span><span class="p">,</span>
                                                 <span class="n">footprint</span><span class="o">=</span><span class="n">se</span><span class="p">,</span>
                                                 <span class="n">mode</span><span class="o">=</span><span class="n">edgeopt</span><span class="p">[</span><span class="n">opt</span><span class="p">]))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">similarity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Locate template in image</span>

<span class="sd">        :param T: template image</span>
<span class="sd">        :type T: numpy array</span>
<span class="sd">        :param metric: similarity metric function</span>
<span class="sd">        :type metric: callable function reference</span>
<span class="sd">        :return S: Image similarity image</span>
<span class="sd">        :rtype S: Image instance</span>

<span class="sd">        - ``IM.similarity(T)`` is an image where each pixel is the ``zncc``</span>
<span class="sd">          similarity of the template ``T`` (M,M) to the (M,M) neighbourhood</span>
<span class="sd">          surrounding the corresonding input pixel in image.  ``S`` is same</span>
<span class="sd">          size as image.</span>

<span class="sd">        - ``IM.similarity(T, metric)`` as above but the similarity metric is</span>
<span class="sd">          specified by the function ``metric`` which can be any of @sad, @ssd,</span>
<span class="sd">          @ncc, @zsad, @zssd.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - For NCC and ZNCC the maximum in S corresponds to the most likely</span>
<span class="sd">              template location.  For SAD, SSD, ZSAD and ZSSD the minimum value</span>
<span class="sd">              corresponds to the most likely location.</span>
<span class="sd">            - Similarity is not computed for those pixels where the template</span>
<span class="sd">              crosses the image boundary, and these output pixels are set</span>
<span class="sd">              to NaN.</span>
<span class="sd">            - The ZNCC function is a MEX file and therefore the fastest</span>
<span class="sd">            - User provided similarity metrics can be used, the function</span>
<span class="sd">              accepts two regions and returns a scalar similarity score.</span>

<span class="sd">        :references:</span>

<span class="sd">            - Robotics, Vision &amp; Control, Section 12.4, P. Corke,</span>
<span class="sd">              Springer 2011.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check inputs</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">((</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s1">&#39;template T must have odd dimensions&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">metric</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">metric</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zncc</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callable</span><span class="p">(</span><span class="n">metric</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">metric</span><span class="p">,</span> <span class="s1">&#39;metric not a callable function&#39;</span><span class="p">)</span>

        <span class="c1"># to use metric, T must be an image class</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

        <span class="n">hc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">hr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

            <span class="c1"># TODO can probably replace these for loops with comprehensions</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">hc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">hc</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">hr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">hr</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">T</span><span class="o">.</span><span class="n">metric</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="n">hr</span><span class="p">:</span><span class="n">r</span><span class="o">+</span><span class="n">hr</span><span class="p">,</span> <span class="n">c</span><span class="o">-</span><span class="n">hc</span><span class="p">:</span><span class="n">c</span><span class="o">+</span><span class="n">hc</span><span class="p">])</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">optmode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">optboundary</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Image convolution</span>

<span class="sd">        :param K: kernel</span>
<span class="sd">        :type K: numpy array</span>
<span class="sd">        :param optmode: option for convolution</span>
<span class="sd">        :type optmode: string</span>
<span class="sd">        :param optboundary: option for boundary handling</span>
<span class="sd">        :type optboundary: string</span>
<span class="sd">        :return C: Image convolved image</span>
<span class="sd">        :rtype C: Image instance</span>

<span class="sd">        - ``IM.convolve(K)`` is the convolution of image with the kernel ``K``</span>

<span class="sd">        - ``IM.convolve(K, optmode)`` as above but specifies the convolution</span>
<span class="sd">          mode. See scipy.signal.convolve2d for details, mode options below</span>

<span class="sd">        - ``IM.convolve(K, optboundary)`` as above but specifies the boundary</span>
<span class="sd">          handling options</span>

<span class="sd">        :options:</span>

<span class="sd">            - &#39;same&#39;    output image is same size as input image (default)</span>
<span class="sd">            - &#39;full&#39;    output image is larger than the input image</span>
<span class="sd">            - &#39;valid&#39;   output image is smaller than the input image, and</span>
<span class="sd">              contains only valid pixels TODO</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - If the image is color (has multiple planes) the kernel is</span>
<span class="sd">              applied to each plane, resulting in an output image with the same</span>
<span class="sd">              number of planes.</span>
<span class="sd">            - If the kernel has multiple planes, the image is convolved with</span>
<span class="sd">              each plane of the kernel, resulting in an output image with the</span>
<span class="sd">              same number of planes.</span>
<span class="sd">            - This function is a convenience wrapper for the MATLAB function</span>
<span class="sd">              CONV2.</span>
<span class="sd">            - Works for double, uint8 or uint16 images.  Image and kernel must</span>
<span class="sd">              be of the same type and the result is of the same type.</span>
<span class="sd">            - This function replaces iconv().</span>

<span class="sd">        :references:</span>

<span class="sd">            - Robotics, Vision &amp; Control, Section 12.4, P. Corke,</span>
<span class="sd">              Springer 2011.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO check images are of the same type</span>

        <span class="c1"># TODO check opt is valid string based on conv2 options</span>
        <span class="n">modeopt</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;full&#39;</span><span class="p">:</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span>
            <span class="s1">&#39;valid&#39;</span><span class="p">:</span> <span class="s1">&#39;valid&#39;</span><span class="p">,</span>
            <span class="s1">&#39;same&#39;</span><span class="p">:</span> <span class="s1">&#39;same&#39;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">optmode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modeopt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">optmode</span><span class="p">,</span> <span class="s1">&#39;opt is not a valid option&#39;</span><span class="p">)</span>

        <span class="n">boundaryopt</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fill&#39;</span><span class="p">:</span> <span class="s1">&#39;fill&#39;</span><span class="p">,</span>
            <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="s1">&#39;wrap&#39;</span><span class="p">,</span>
            <span class="s1">&#39;reflect&#39;</span><span class="p">:</span> <span class="s1">&#39;symm&#39;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">optboundary</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">boundaryopt</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">optboundary</span><span class="p">,</span> <span class="s1">&#39;opt is not a valid option&#39;</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">iscolor</span> <span class="ow">and</span> <span class="n">K</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># image has multiple planes:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">],</span>
                                                 <span class="n">K</span><span class="p">,</span>
                                                 <span class="n">mode</span><span class="o">=</span><span class="n">modeopt</span><span class="p">[</span><span class="n">optmode</span><span class="p">],</span>
                                                 <span class="n">boundary</span><span class="o">=</span><span class="n">boundaryopt</span><span class="p">[</span>
                                                     <span class="n">optboundary</span><span class="p">])</span>
                               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">nchannels</span><span class="p">)])</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">im</span><span class="o">.</span><span class="n">iscolor</span> <span class="ow">and</span> <span class="n">K</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># simple case, convolve image with kernel, both are 2D</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                                      <span class="n">K</span><span class="p">,</span>
                                      <span class="n">mode</span><span class="o">=</span><span class="n">modeopt</span><span class="p">[</span><span class="n">optmode</span><span class="p">],</span>
                                      <span class="n">boundary</span><span class="o">=</span><span class="n">boundaryopt</span><span class="p">[</span><span class="n">optboundary</span><span class="p">])</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">im</span><span class="o">.</span><span class="n">iscolor</span> <span class="ow">and</span> <span class="n">K</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># kernel has multiple planes:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">signal</span><span class="o">.</span><span class="n">convolve2d</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">image</span><span class="p">,</span>
                                                 <span class="n">K</span><span class="o">.</span><span class="n">image</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">],</span>
                                                 <span class="n">mode</span><span class="o">=</span><span class="n">modeopt</span><span class="p">[</span><span class="n">optmode</span><span class="p">],</span>
                                                 <span class="n">boundary</span><span class="o">=</span><span class="n">boundaryopt</span><span class="p">[</span>
                                                     <span class="n">optboundary</span><span class="p">])</span>
                               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="n">im</span><span class="p">,</span> <span class="s1">&#39;image and kernel cannot both have muliple planes&#39;</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">canny</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">th0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">th1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Canny edge detection</span>

<span class="sd">        :param sigma: standard deviation for Gaussian kernel smoothing</span>
<span class="sd">        :type sigma: float</span>
<span class="sd">        :param th0: lower threshold</span>
<span class="sd">        :type th0: float</span>
<span class="sd">        :param th1: upper threshold</span>
<span class="sd">        :type th1: float</span>
<span class="sd">        :return E: Image with edge image</span>
<span class="sd">        :rtype E: Image instance</span>

<span class="sd">        - ``IM.canny()`` is an edge image obtained using the Canny edge</span>
<span class="sd">          detector algorithm.  Hysteresis filtering is applied to the gradient</span>
<span class="sd">          image: edge pixels &gt; ``th1`` are connected to adjacent pixels &gt;</span>
<span class="sd">          ``th0``, those below ``th0`` are set to zero.</span>

<span class="sd">        - ``IM.canny(sigma, th0, th1)`` as above, but the standard deviation of</span>
<span class="sd">          the Gaussian smoothing, ``sigma``, lower and upper thresholds</span>
<span class="sd">          ``th0``, ``th1`` can be specified</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">        .. note::</span>

<span class="sd">            - Produces a zero image with single pixel wide edges having</span>
<span class="sd">              non-zero values.</span>
<span class="sd">            - Larger values correspond to stronger edges.</span>
<span class="sd">            - If th1 is zero then no hysteresis filtering is performed.</span>
<span class="sd">            - A color image is automatically converted to greyscale first.</span>

<span class="sd">        :references:</span>

<span class="sd">            - &quot;A Computational Approach To Edge Detection&quot;, J. Canny,</span>
<span class="sd">              IEEE Trans. Pattern Analysis and Machine Intelligence,</span>
<span class="sd">              8(6):679698, 1986.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># convert to greyscale:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mono</span><span class="p">()</span>

        <span class="c1"># set defaults (eg thresholds, eg one as a function of the other)</span>
        <span class="k">if</span> <span class="n">th0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">th0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">):</span>
                <span class="n">th0</span> <span class="o">=</span> <span class="mf">0.1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># isint</span>
                <span class="n">th0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">th1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">th1</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">th0</span>

        <span class="c1"># compute gradients Ix, Iy using guassian kernel</span>
        <span class="n">dg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdgauss</span><span class="p">(</span><span class="n">sigma</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="n">img</span><span class="p">:</span>

            <span class="n">Ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">dg</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">))</span>
            <span class="n">Iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">dg</span><span class="p">),</span> <span class="s1">&#39;same&#39;</span><span class="p">))</span>

            <span class="c1"># Ix, Iy must be 16-bit input image</span>
            <span class="n">Ix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Ix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
            <span class="n">Iy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Iy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cv</span><span class="o">.</span><span class="n">Canny</span><span class="p">(</span><span class="n">Ix</span><span class="p">,</span> <span class="n">Iy</span><span class="p">,</span> <span class="n">th0</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">L2gradient</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<span class="c1"># --------------------------------------------------------------------------#</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ImageProcessingKernel.py&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">machinevisiontoolbox</span> <span class="kn">import</span> <span class="n">Image</span>

    <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">(</span><span class="s1">&#39;monalisa.png&#39;</span><span class="p">,</span> <span class="n">grey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">blur</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">blur</span><span class="o">.</span><span class="n">disp</span><span class="p">(</span><span class="n">block</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 
      <span class="lastupdated">
        Last updated on 28-Jan-2021.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>