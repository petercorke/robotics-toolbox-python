<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>roboticstoolbox.robot.ETS &mdash; Robotics Toolbox for Python  documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Robotics Toolbox for Python
              <img src="../../../_static/RobToolBox_RoundLogoB.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../arm.html">Robot Arms</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mobile.html">Mobile robots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../blocks.html">bdsim blocks</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Robotics Toolbox for Python</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">roboticstoolbox.robot.ETS</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for roboticstoolbox.robot.ETS</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">@author: Jesse Haviland</span>
<span class="sd">@author: Peter Corke</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">UserList</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.random</span> <span class="kn">import</span> <span class="n">uniform</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span><span class="p">,</span> <span class="n">det</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">svd</span>
<span class="kn">from</span> <span class="nn">spatialmath</span> <span class="kn">import</span> <span class="n">SE3</span><span class="p">,</span> <span class="n">SE2</span>
<span class="kn">from</span> <span class="nn">spatialmath.base</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">getvector</span><span class="p">,</span>
    <span class="n">issymbol</span><span class="p">,</span>
    <span class="n">tr2jac</span><span class="p">,</span>
    <span class="n">verifymatrix</span><span class="p">,</span>
    <span class="n">tr2jac2</span><span class="p">,</span>
    <span class="n">t2r</span><span class="p">,</span>
    <span class="n">rotvelxform</span><span class="p">,</span>
    <span class="n">simplify</span><span class="p">,</span>
    <span class="n">getmatrix</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">roboticstoolbox</span> <span class="kn">import</span> <span class="n">rtb_get_param</span>
<span class="kn">from</span> <span class="nn">roboticstoolbox.robot.IK</span> <span class="kn">import</span> <span class="n">IK_GN</span><span class="p">,</span> <span class="n">IK_LM</span><span class="p">,</span> <span class="n">IK_NR</span><span class="p">,</span> <span class="n">IK_QP</span>

<span class="kn">from</span> <span class="nn">roboticstoolbox.fknm</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ETS_init</span><span class="p">,</span>
    <span class="n">ETS_fkine</span><span class="p">,</span>
    <span class="n">ETS_jacob0</span><span class="p">,</span>
    <span class="n">ETS_jacobe</span><span class="p">,</span>
    <span class="n">ETS_hessian0</span><span class="p">,</span>
    <span class="n">ETS_hessiane</span><span class="p">,</span>
    <span class="n">IK_NR_c</span><span class="p">,</span>
    <span class="n">IK_GN_c</span><span class="p">,</span>
    <span class="n">IK_LM_c</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">roboticstoolbox.robot.ET</span> <span class="kn">import</span> <span class="n">ET</span><span class="p">,</span> <span class="n">ET2</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">overload</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">typing_extensions</span> <span class="kn">import</span> <span class="n">Literal</span> <span class="k">as</span> <span class="n">L</span>
<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">version_info</span>
<span class="kn">from</span> <span class="nn">roboticstoolbox.tools.types</span> <span class="kn">import</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">NDArray</span>

<span class="n">py_ver</span> <span class="o">=</span> <span class="n">version_info</span>

<span class="k">if</span> <span class="n">version_info</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">):</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cached_property</span>

    <span class="n">c_property</span> <span class="o">=</span> <span class="n">cached_property</span>
<span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
    <span class="n">c_property</span> <span class="o">=</span> <span class="nb">property</span>


<span class="k">class</span> <span class="nc">BaseETS</span><span class="p">(</span><span class="n">UserList</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_internals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="kc">True</span> <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isjoint</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span> <span class="o">=</span> <span class="n">ETS_init</span><span class="p">(</span>
            <span class="p">[</span><span class="n">et</span><span class="o">.</span><span class="n">fknm</span> <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_m</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># self._fknm = [et.fknm for et in self.data]</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty prints the ETS</span>

<span class="sd">        ``q`` controls how the joint variables are displayed:</span>

<span class="sd">        - None, format depends on number of joint variables</span>
<span class="sd">            - one, display joint variable as q</span>
<span class="sd">            - more, display joint variables as q0, q1, ...</span>
<span class="sd">            - if a joint index was provided, use this value</span>
<span class="sd">        - &quot;&quot;, display all joint variables as empty parentheses ``()``</span>
<span class="sd">        - &quot;Œ∏&quot;, display all joint variables as ``(Œ∏)``</span>
<span class="sd">        - format string with passed joint variables ``(j, j+1)``, so &quot;Œ∏{0}&quot;</span>
<span class="sd">          would display joint variables as Œ∏0, Œ∏1, ... while &quot;Œ∏{1}&quot; would</span>
<span class="sd">          display joint variables as Œ∏1, Œ∏2, ...  ``j`` is either the joint</span>
<span class="sd">          index, if provided, otherwise a sequential value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            control how joint variables are displayed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            Pretty printed ETS</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz()</span>
<span class="sd">        &gt;&gt;&gt; print(e[:2])</span>
<span class="sd">        &gt;&gt;&gt; print(e)</span>
<span class="sd">        &gt;&gt;&gt; print(e.__str__(&quot;&quot;))</span>
<span class="sd">        &gt;&gt;&gt; print(e.__str__(&quot;Œ∏{0}&quot;))  # numbering from 0</span>
<span class="sd">        &gt;&gt;&gt; print(e.__str__(&quot;Œ∏{1}&quot;))  # numbering from 1</span>
<span class="sd">        &gt;&gt;&gt; # explicit joint indices</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz(jindex=3) * ET.tx(1) * ET.Rz(jindex=4)</span>
<span class="sd">        &gt;&gt;&gt; print(e)</span>
<span class="sd">        &gt;&gt;&gt; print(e.__str__(&quot;Œ∏{0}&quot;))</span>

<span class="sd">        Angular parameters are converted to degrees, except if they</span>
<span class="sd">        are symbolic.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; from spatialmath.base import symbol</span>
<span class="sd">        &gt;&gt;&gt; theta, d = symbol(&#39;theta, d&#39;)</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rx(theta) * ET.tx(2) * ET.Rx(45, &#39;deg&#39;) * ET.Ry(0.2) * ET.ty(d)</span>
<span class="sd">        &gt;&gt;&gt; str(e)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">es</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">s</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">unicode</span> <span class="o">=</span> <span class="n">rtb_get_param</span><span class="p">(</span><span class="s2">&quot;unicode&quot;</span><span class="p">)</span>

        <span class="c1"># An empty SE3</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;SE3()&quot;</span>

        <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;q</span><span class="si">{0}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q</span> <span class="o">=</span> <span class="s2">&quot;q&quot;</span>

        <span class="c1"># For et in the object, display it, data comes from properties</span>
        <span class="c1"># which come from the named tuple</span>
        <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isjoint</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">q</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: nocover  this is no longer possible</span>
                        <span class="n">_j</span> <span class="o">=</span> <span class="n">j</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_j</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">jindex</span>
                    <span class="n">qvar</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>  <span class="c1"># lgtm [py/str-format/surplus-argument]  # noqa</span>
                        <span class="n">_j</span><span class="p">,</span> <span class="n">_j</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="p">)</span>
                <span class="c1"># else:</span>
                <span class="c1">#     qvar = &quot;&quot;</span>

                <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isflip</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(-</span><span class="si">{</span><span class="n">qvar</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">qvar</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">elif</span> <span class="n">et</span><span class="o">.</span><span class="n">isrotation</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">issymbol</span><span class="p">(</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">180</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">¬∞)&quot;</span>

            <span class="k">elif</span> <span class="n">et</span><span class="o">.</span><span class="n">istranslation</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">axis</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">et</span><span class="o">.</span><span class="n">eta</span><span class="si">}</span><span class="s2">)&quot;</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">et</span><span class="o">.</span><span class="n">iselementary</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
                <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">es</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unicode</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot; </span><span class="se">\u2295</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="k">return</span> <span class="s2">&quot; * &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">es</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_repr_pretty_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">cycle</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pretty string for IPython</span>

<span class="sd">        Print stringified version when variable is displayed in IPython, ie. on</span>
<span class="sd">        a line by itself.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p</span>
<span class="sd">            pretty printer handle (ignored)</span>
<span class="sd">        cycle</span>
<span class="sd">            pretty printer flag (ignored)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        In [1]: e</span>
<span class="sd">        Out [1]: R(q0) ‚äï tx(1) ‚äï R(q1) ‚äï tx(1)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">())</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="nf">joint_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get index of joint transforms</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        joint_idx</span>
<span class="sd">            indices of transforms that are joints</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">        &gt;&gt;&gt; e.joint_idx()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span> <span class="nf">joints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list of the variable ETs with this ETS</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        joints</span>
<span class="sd">            list of ETs that are joints</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">        &gt;&gt;&gt; e.joints()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">isjoint</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">jindex_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>  <span class="c1">#</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get set of joint indices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jindex_set</span>
<span class="sd">            set of unique joint indices</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz(jindex=1) * ET.tx(jindex=2) * ET.Rz(jindex=1) * ET.tx(1)</span>
<span class="sd">        &gt;&gt;&gt; e.jointset()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">joint_idx</span><span class="p">()])</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@c_property</span>
    <span class="k">def</span> <span class="nf">jindices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an array of joint indices</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jindices</span>
<span class="sd">            array of unique joint indices</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz(jindex=1) * ET.tx(jindex=2) * ET.Rz(jindex=1) * ET.tx(1)</span>
<span class="sd">        &gt;&gt;&gt; e.jointset()</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span><span class="o">.</span><span class="n">jindex</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">()])</span>  <span class="c1"># type: ignore</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">qlim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get/Set Joint limits</span>

<span class="sd">        Limits are extracted from the link objects.  If joints limits are</span>
<span class="sd">        not set for:</span>

<span class="sd">        - a revolute joint [-ùúã. ùúã] is returned</span>
<span class="sd">        - a prismatic joint an exception is raised</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_qlim</span>
<span class="sd">            An ndarray(2, n) of the new joint limits to set</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :return: Array of joint limit values</span>
<span class="sd">        :rtype: ndarray(2,n)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            unset limits for a prismatic joint</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; robot = rtb.models.DH.Puma560()</span>
<span class="sd">        &gt;&gt;&gt; robot.qlim</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">et</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isrotation</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">qlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">qlim</span>
            <span class="k">elif</span> <span class="n">et</span><span class="o">.</span><span class="n">istranslation</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">qlim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;undefined prismatic joint limit&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">qlim</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Undefined Joint Type&quot;</span><span class="p">)</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">limits</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">limits</span>

    <span class="nd">@qlim</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">qlim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_qlim</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">):</span>
        <span class="n">new_qlim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">new_qlim</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_qlim</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">new_qlim</span> <span class="o">=</span> <span class="n">new_qlim</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_qlim</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;new_qlim must be of shape (2, n)&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joint_idx</span><span class="p">()):</span>
            <span class="n">et</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">et</span><span class="o">.</span><span class="n">qlim</span> <span class="o">=</span> <span class="n">new_qlim</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>

            <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">et</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">structure</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Joint structure string</span>

<span class="sd">        A string comprising the characters &#39;R&#39; or &#39;P&#39; which indicate the types</span>
<span class="sd">        of joints in order from left to right.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        structure</span>
<span class="sd">            A string indicating the joint types</span>



<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.tz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">        &gt;&gt;&gt; e.structure</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="s2">&quot;R&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isrotation</span> <span class="k">else</span> <span class="s2">&quot;P&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">joint_idx</span><span class="p">()]</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of joints</span>

<span class="sd">        Counts the number of joints in the ETS.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n</span>
<span class="sd">            the number of joints in the ETS</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rx() * ET.tx(1) * ET.tz()</span>
<span class="sd">        &gt;&gt;&gt; e.n</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`joints`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of transforms</span>

<span class="sd">        Counts the number of transforms in the ETS.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        m</span>
<span class="sd">            the number of transforms in the ETS</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rx() * ET.tx(1) * ET.tz()</span>
<span class="sd">        &gt;&gt;&gt; e.m</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">]:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET2</span><span class="p">]:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">new_data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">]):</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">new_data</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ET2</span><span class="p">]):</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@data</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">new_data</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ET</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ET2</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pop value</span>

<span class="sd">        Removes a value from the value list and returns it.  The original</span>
<span class="sd">        instance is modified.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i</span>
<span class="sd">            item in the list to pop, default is last</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pop</span>
<span class="sd">            the popped value</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        IndexError</span>
<span class="sd">            if there are no values to pop</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">        &gt;&gt;&gt; tail = e.pop()</span>
<span class="sd">        &gt;&gt;&gt; tail</span>
<span class="sd">        &gt;&gt;&gt; e</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">item</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">item</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ETS&quot;</span><span class="p">]:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ETS2&quot;</span><span class="p">]:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split ETS into link segments</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        split</span>
<span class="sd">            a list of ETS, each one, apart from the last,</span>
<span class="sd">            ends with a variable ET.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joint_idx</span><span class="p">()):</span>
            <span class="n">ets_j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">start</span> <span class="p">:</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ets_j</span><span class="p">)</span>

        <span class="n">tail</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">tail_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">tail</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tail_len</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tail_len</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">tail_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">segments</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverse of ETS</span>

<span class="sd">        The inverse of a given ETS.  It is computed as the inverse of the</span>
<span class="sd">        individual ETs in the reverse order.</span>

<span class="sd">        .. math::</span>

<span class="sd">            (\mathbf{E}_0, \mathbf{E}_1 \cdots \mathbf{E}_{n-1} )^{-1} = (\mathbf{E}_{n-1}^{-1}, \mathbf{E}_{n-2}^{-1} \cdots \mathbf{E}_0^{-1}{n-1} )</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        inv</span>
<span class="sd">            Inverse of the ETS</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz(jindex=2) * ET.tx(1) * ET.Rx(jindex=3,flip=True) * ET.tx(1)</span>
<span class="sd">        &gt;&gt;&gt; print(e)</span>
<span class="sd">        &gt;&gt;&gt; print(e.inv())</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - It is essential to use explicit joint indices to account for</span>
<span class="sd">            the reversed order of the transforms.</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">([</span><span class="n">et</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span> <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)])</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ET</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">]:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ET2</span><span class="p">:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">ET2</span><span class="p">]:</span>
        <span class="o">...</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Index or slice an ETS</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i</span>
<span class="sd">            the index or slince</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        et</span>
<span class="sd">            Elementary transform</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">        &gt;&gt;&gt; e[0]</span>
<span class="sd">        &gt;&gt;&gt; e[1]</span>
<span class="sd">        &gt;&gt;&gt; e[1:3]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># can be [2] or slice, eg. [3:5]</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">roboticstoolbox.robot.Robot</span> <span class="kn">import</span> <span class="n">Robot</span><span class="p">,</span> <span class="n">Robot2</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
            <span class="n">robot</span> <span class="o">=</span> <span class="n">Robot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">robot</span> <span class="o">=</span> <span class="n">Robot2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">robot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">teach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">roboticstoolbox.robot.Robot</span> <span class="kn">import</span> <span class="n">Robot</span><span class="p">,</span> <span class="n">Robot2</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
            <span class="n">robot</span> <span class="o">=</span> <span class="n">Robot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">robot</span> <span class="o">=</span> <span class="n">Robot2</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">robot</span><span class="o">.</span><span class="n">teach</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">random_q</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a random valid joint configuration</span>

<span class="sd">        Generates a random q vector within the joint limits defined by</span>
<span class="sd">        `self.qlim`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i</span>
<span class="sd">            number of configurations to generate</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; robot = rtb.models.Panda()</span>
<span class="sd">        &gt;&gt;&gt; ets = robot.ets()</span>
<span class="sd">        &gt;&gt;&gt; q = ets.random_q()</span>
<span class="sd">        &gt;&gt;&gt; q</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qlim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">qlim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                    <span class="n">q</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qlim</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">qlim</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">q</span>


<div class="viewcode-block" id="ETS"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS">[docs]</a><span class="k">class</span> <span class="nc">ETS</span><span class="p">(</span><span class="n">BaseETS</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements an elementary transform sequence (ETS) for 3D</span>

<span class="sd">    An instance can contain an elementary transform (ET) or an elementary</span>
<span class="sd">    transform sequence (ETS). It has list-like properties by subclassing</span>
<span class="sd">    UserList, which means we can perform indexing, slicing pop, insert, as well</span>
<span class="sd">    as using it as an iterator over its values.</span>

<span class="sd">    - ``ETS()`` an empty ETS list</span>
<span class="sd">    - ``ETS(et)`` an ETS containing a single ET</span>
<span class="sd">    - ``ETS([et0, et1, et2])`` an ETS consisting of three ET&#39;s</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arg</span>
<span class="sd">        Function to compute ET value</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. runblock:: pycon</span>
<span class="sd">    &gt;&gt;&gt; from roboticstoolbox import ETS, ET</span>
<span class="sd">    &gt;&gt;&gt; e = ET.Rz(0.3) # a single ET, rotation about z</span>
<span class="sd">    &gt;&gt;&gt; ets1 = ETS(e)</span>
<span class="sd">    &gt;&gt;&gt; len(ets1)</span>
<span class="sd">    &gt;&gt;&gt; ets2 = ET.Rz(0.3) * ET.tx(2) # an ETS</span>
<span class="sd">    &gt;&gt;&gt; len(ets2)                    # of length 2</span>
<span class="sd">    &gt;&gt;&gt; ets2[1]                      # an ET sliced from the ETS</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">        Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">    - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">        Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`rx`</span>
<span class="sd">    :func:`ry`</span>
<span class="sd">    :func:`rz`</span>
<span class="sd">    :func:`tx`</span>
<span class="sd">    :func:`ty`</span>
<span class="sd">    :func:`tz`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="n">ET</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">ET</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ETS&quot;</span><span class="p">],</span> <span class="n">ET</span><span class="p">,</span> <span class="s2">&quot;ETS&quot;</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ET</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ets_item</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ets_item</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid arg&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ET</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ets_item</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ets_item</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid arg&quot;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check if jindices are set</span>
        <span class="n">joints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">()</span>

        <span class="c1"># Number of joints with a jindex</span>
        <span class="n">jindices</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Number of joints with a sequential jindex (j[2] -&gt; jindex = 2)</span>
        <span class="n">seq_jindex</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Count them up</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">joint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">joints</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jindices</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">seq_jindex</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">jindices</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">seq_jindex</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">joints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="c1"># ets has sequential jindicies, except for the last.</span>
            <span class="n">joints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="n">jindices</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">jindices</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You can not have some jindices set for the ET&#39;s in arg. It must be all&quot;</span>
                <span class="s2">&quot; or none&quot;</span>
            <span class="p">)</span>  <span class="c1"># pragma: nocover</span>
        <span class="k">elif</span> <span class="n">jindices</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Set them ourself</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">joint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">joints</span><span class="p">):</span>
                <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="n">j</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ETS.__mul__"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ET&quot;</span><span class="p">,</span> <span class="s2">&quot;ETS&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ET</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ETS</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>  <span class="c1"># pragma: nocover</span></div>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ET&quot;</span><span class="p">,</span> <span class="s2">&quot;ETS&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ETS</span><span class="p">([</span><span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="s2">&quot;ETS&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">rest</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>  <span class="c1"># pragma: nocover</span>

<div class="viewcode-block" id="ETS.compile"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile an ETS</span>

<span class="sd">        Perform constant folding for faster evaluation.  Consecutive constant</span>
<span class="sd">        ETs are compounded, leading to a constant ET which is denoted by</span>
<span class="sd">        ``SE3`` when displayed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        compile</span>
<span class="sd">            optimised ETS</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; robot = rtb.models.ETS.Panda()</span>
<span class="sd">        &gt;&gt;&gt; ets = robot.ets()</span>
<span class="sd">        &gt;&gt;&gt; ets</span>
<span class="sd">        &gt;&gt;&gt; ets.compile()</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :func:`isconstant`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">const</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ets</span> <span class="o">=</span> <span class="n">ETS</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isjoint</span><span class="p">:</span>
                <span class="c1"># a joint</span>
                <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># flush the constant</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span>
                        <span class="n">ets</span> <span class="o">*=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SE3</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ets</span> <span class="o">*=</span> <span class="n">et</span>  <span class="c1"># emit the joint ET</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># not a joint</span>
                <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="n">const</span> <span class="o">@</span> <span class="n">et</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># flush the constant, tool transform</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)):</span>
                <span class="n">ets</span> <span class="o">*=</span> <span class="n">ET</span><span class="o">.</span><span class="n">SE3</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ets</span></div>

<div class="viewcode-block" id="ETS.insert"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ET</span><span class="p">,</span> <span class="s2">&quot;ETS&quot;</span><span class="p">],</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert value</span>

<span class="sd">        Inserts an ET or ETS into the ET sequence.  The inserted value is at position</span>
<span class="sd">        ``i``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        i</span>
<span class="sd">            insert an ET or ETS into the ETS, default is at the end</span>
<span class="sd">        arg</span>
<span class="sd">            the elementary transform or sequence to insert</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; from roboticstoolbox import ET</span>
<span class="sd">        &gt;&gt;&gt; e = ET.Rz() * ET.tx(1) * ET.Rz() * ET.tx(1)</span>
<span class="sd">        &gt;&gt;&gt; f = ET.Ry()</span>
<span class="sd">        &gt;&gt;&gt; e.insert(f, 2)</span>
<span class="sd">        &gt;&gt;&gt; e</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ET</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ETS</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">et</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">et</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span></div>

<div class="viewcode-block" id="ETS.fkine"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.fkine">[docs]</a>    <span class="k">def</span> <span class="nf">fkine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_base</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE3</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward kinematics</span>

<span class="sd">        ``T = ets.fkine(q)`` evaluates forward kinematics for the ets at</span>
<span class="sd">        joint configuration ``q``.</span>

<span class="sd">        **Trajectory operation**:</span>
<span class="sd">        If ``q`` has multiple rows (mxn), it is considered a trajectory and the</span>
<span class="sd">        result is an ``SE3`` instance with ``m`` values.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            Joint coordinates</span>
<span class="sd">        base</span>
<span class="sd">            A base transform applied before the ETS</span>
<span class="sd">        tool</span>
<span class="sd">            tool transform, optional</span>
<span class="sd">        include_base</span>
<span class="sd">            set to True if the base transform should be considered</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The transformation matrix representing the pose of the</span>
<span class="sd">            end-effector</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example makes a ``panda`` robot object, gets the ets, and</span>
<span class="sd">        solves for the forward kinematics at the listed configuration.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; panda.fkine([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - A tool transform, if provided, is incorporated into the result.</span>
<span class="sd">        - Works from the end-effector link to the base</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">SE3</span><span class="o">.</span><span class="n">Empty</span><span class="p">()</span>
        <span class="n">fk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">include_base</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fk</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span><span class="p">:</span>
            <span class="c1"># symbolic</span>
            <span class="n">fk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">fk</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">fk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">fk</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SE3</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">(</span><span class="n">fk</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_base</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward kinematics</span>

<span class="sd">        ``T = ets.fkine(q)`` evaluates forward kinematics for the ets at</span>
<span class="sd">        joint configuration ``q``.</span>

<span class="sd">        **Trajectory operation**:</span>
<span class="sd">        If ``q`` has multiple rows (mxn), it is considered a trajectory and the</span>
<span class="sd">        result is an ``SE3`` instance with ``m`` values.</span>

<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            Joint coordinates</span>
<span class="sd">        base</span>
<span class="sd">            A base transform applied before the ETS</span>
<span class="sd">        tool</span>
<span class="sd">            tool transform, optional</span>
<span class="sd">        include_base</span>
<span class="sd">            set to True if the base transform should be considered</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            The transformation matrix representing the pose of the</span>
<span class="sd">            end-effector</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example makes a ``panda`` robot object, gets the ets, and</span>
<span class="sd">        solves for the forward kinematics at the listed configuration.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; panda.fkine([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - A tool transform, if provided, is incorporated into the result.</span>
<span class="sd">        - Works from the end-effector link to the base</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_fkine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">include_base</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">BaseException</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">getmatrix</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># type: ignore</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="n">tool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tool</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">base</span>

        <span class="k">if</span> <span class="n">tool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">tool</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="c1"># Tk = None</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">qk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
            <span class="n">link</span> <span class="o">=</span> <span class="n">end</span>  <span class="c1"># start with last link</span>

            <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>

            <span class="n">Tk</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">qk</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">tools</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tk</span> <span class="o">=</span> <span class="n">Tk</span> <span class="o">@</span> <span class="n">tools</span>

            <span class="c1"># add remaining links, back toward the base</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">qk</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">Tk</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">Tk</span>

            <span class="c1"># add base transform if it is set</span>
            <span class="k">if</span> <span class="n">include_base</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">bases</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tk</span> <span class="o">=</span> <span class="n">bases</span> <span class="o">@</span> <span class="n">Tk</span>

            <span class="c1"># append</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Tk</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">Tk</span>

        <span class="k">return</span> <span class="n">T</span>

<div class="viewcode-block" id="ETS.jacob0"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.jacob0">[docs]</a>    <span class="k">def</span> <span class="nf">jacob0</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator geometric Jacobian in the base frame</span>

<span class="sd">        ``robot.jacobo(q)`` is the manipulator Jacobian matrix which maps</span>
<span class="sd">        joint  velocity to end-effector spatial velocity expressed in the</span>
<span class="sd">        base frame.</span>

<span class="sd">        End-effector spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x, \omega_y, \omega_z)^T`</span>
<span class="sd">        is related to joint velocity by :math:`{}^{E}\!\nu = \mathbf{J}_m(q) \dot{q}`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            Joint coordinate vector</span>
<span class="sd">        tool</span>
<span class="sd">            a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        J0</span>
<span class="sd">            Manipulator Jacobian in the base frame</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example makes a ``Puma560`` robot object, and solves for the</span>
<span class="sd">        base-frame Jacobian at the zero joint angle configuration</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; puma = rtb.models.Puma560().ets()</span>
<span class="sd">        &gt;&gt;&gt; puma.jacob0([0, 0, 0, 0, 0, 0])</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This is the geometric Jacobian as described in texts by</span>
<span class="sd">            Corke, Spong etal., Siciliano etal.  The end-effector velocity is</span>
<span class="sd">            described in terms of translational and angular velocity, not a</span>
<span class="sd">            velocity twist as per the text by Lynch &amp; Park.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="c1"># Use c extension</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_jacob0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Otherwise use Python</span>
        <span class="k">if</span> <span class="n">tool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">SE3</span><span class="p">):</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tool</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">include_base</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">@</span> <span class="n">tools</span>

        <span class="n">U</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;object&quot;</span><span class="p">)</span>
        <span class="n">zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>

            <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span><span class="p">:</span>
                <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

                <span class="k">if</span> <span class="n">link</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
                    <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">tools</span>

                <span class="n">Tu</span> <span class="o">=</span> <span class="n">SE3</span><span class="p">(</span><span class="n">U</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">inv</span><span class="p">()</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="n">T</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">o</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">Tu</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">Tu</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
                <span class="n">z</span> <span class="o">=</span> <span class="n">Tu</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;Rz&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">o</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;Ry&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;Rx&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">o</span> <span class="o">*</span> <span class="n">z</span><span class="p">)</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;tx&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;ty&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">o</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span>

                <span class="k">elif</span> <span class="n">link</span><span class="o">.</span><span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;tz&quot;</span><span class="p">:</span>
                    <span class="n">J</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
                    <span class="n">J</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero</span>

                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">U</span> <span class="o">=</span> <span class="n">U</span> <span class="o">@</span> <span class="n">A</span>

        <span class="k">return</span> <span class="n">J</span></div>

<div class="viewcode-block" id="ETS.jacobe"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.jacobe">[docs]</a>    <span class="k">def</span> <span class="nf">jacobe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator geometric Jacobian in the end-effector frame</span>

<span class="sd">        ``robot.jacobe(q)`` is the manipulator Jacobian matrix which maps</span>
<span class="sd">        joint  velocity to end-effector spatial velocity expressed in the</span>
<span class="sd">        ``end`` frame.</span>

<span class="sd">        End-effector spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x, \omega_y, \omega_z)^T`</span>
<span class="sd">        is related to joint velocity by :math:`{}^{E}\!\nu = \mathbf{J}_m(q) \dot{q}`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            Joint coordinate vector</span>
<span class="sd">        end</span>
<span class="sd">            the particular link or gripper whose velocity the Jacobian</span>
<span class="sd">            describes, defaults to the end-effector if only one is present</span>
<span class="sd">        start</span>
<span class="sd">            the link considered as the base frame, defaults to the robots&#39;s base frame</span>
<span class="sd">        tool</span>
<span class="sd">            a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Je</span>
<span class="sd">            Manipulator Jacobian in the ``end`` frame</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example makes a ``Puma560`` robot object, and solves for the</span>
<span class="sd">        end-effector frame Jacobian at the zero joint angle configuration</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; puma = rtb.models.Puma560().ets()</span>
<span class="sd">        &gt;&gt;&gt; puma.jacobe([0, 0, 0, 0, 0, 0])</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - This is the geometric Jacobian as described in texts by</span>
<span class="sd">            Corke, Spong etal., Siciliano etal.  The end-effector velocity is</span>
<span class="sd">            described in terms of translational and angular velocity, not a</span>
<span class="sd">            velocity twist as per the text by Lynch &amp; Park.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="c1"># Use c extension</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_jacobe</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">,</span> <span class="n">include_base</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tr2jac</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span></div>

<div class="viewcode-block" id="ETS.hessian0"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.hessian0">[docs]</a>    <span class="k">def</span> <span class="nf">hessian0</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">J0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator Hessian</span>

<span class="sd">        The manipulator Hessian tensor maps joint acceleration to end-effector</span>
<span class="sd">        spatial acceleration, expressed in the base frame. This</span>
<span class="sd">        function calulcates this based on the ETS of the robot. One of J0 or q</span>
<span class="sd">        is required. Supply J0 if already calculated to save computation time</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            The joint angles/configuration of the robot (Optional,</span>
<span class="sd">            if not supplied will use the stored q values).</span>
<span class="sd">        J0</span>
<span class="sd">            The manipulator Jacobian in the base frame</span>
<span class="sd">        tool</span>
<span class="sd">            a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        h0</span>
<span class="sd">            The manipulator Hessian in the base frame</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        This method computes the manipulator Hessian in the base frame.  If</span>
<span class="sd">        we take the time derivative of the differential kinematic relationship</span>
<span class="sd">        .. math::</span>
<span class="sd">            \nu    &amp;= \mat{J}(\vec{q}) \dvec{q} \\</span>
<span class="sd">            \alpha &amp;= \dmat{J} \dvec{q} + \mat{J} \ddvec{q}</span>
<span class="sd">        where</span>
<span class="sd">        .. math::</span>
<span class="sd">            \dmat{J} = \mat{H} \dvec{q}</span>
<span class="sd">        and :math:`\mat{H} \in \mathbb{R}^{6\times n \times n}` is the</span>
<span class="sd">        Hessian tensor.</span>

<span class="sd">        The elements of the Hessian are</span>
<span class="sd">        .. math::</span>
<span class="sd">            \mat{H}_{i,j,k} =  \frac{d^2 u_i}{d q_j d q_k}</span>
<span class="sd">        where :math:`u = \{t_x, t_y, t_z, r_x, r_y, r_z\}` are the elements</span>
<span class="sd">        of the spatial velocity vector.</span>

<span class="sd">        Similarly, we can write</span>
<span class="sd">        .. math::</span>
<span class="sd">            \mat{J}_{i,j} = \frac{d u_i}{d q_j}</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example makes a ``Panda`` robot object, and solves for the</span>
<span class="sd">        base frame Hessian at the given joint angle configuration</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; panda.hessian0([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="c1"># Use c extension</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_hessian0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">J0</span><span class="p">,</span> <span class="n">tool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="k">if</span> <span class="n">J0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">J0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verifymatrix</span><span class="p">(</span><span class="n">J0</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">J0</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">J0</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">J0</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">J0</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">i</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">H</span></div>

<div class="viewcode-block" id="ETS.hessiane"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS.hessiane">[docs]</a>    <span class="k">def</span> <span class="nf">hessiane</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">Je</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator Hessian</span>

<span class="sd">        The manipulator Hessian tensor maps joint acceleration to end-effector</span>
<span class="sd">        spatial acceleration, expressed in the end-effector coordinate frame. This</span>
<span class="sd">        function calulcates this based on the ETS of the robot. One of J0 or q</span>
<span class="sd">        is required. Supply J0 if already calculated to save computation time</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            The joint angles/configuration of the robot (Optional,</span>
<span class="sd">            if not supplied will use the stored q values).</span>
<span class="sd">        J0</span>
<span class="sd">            The manipulator Jacobian in the end-effector frame</span>
<span class="sd">        tool</span>
<span class="sd">            a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        he</span>
<span class="sd">            The manipulator Hessian in end-effector frame</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        This method computes the manipulator Hessian in the end-effector frame.  If</span>
<span class="sd">        we take the time derivative of the differential kinematic relationship</span>
<span class="sd">        .. math::</span>
<span class="sd">            \nu    &amp;= \mat{J}(\vec{q}) \dvec{q} \\</span>
<span class="sd">            \alpha &amp;= \dmat{J} \dvec{q} + \mat{J} \ddvec{q}</span>
<span class="sd">        where</span>
<span class="sd">        .. math::</span>
<span class="sd">            \dmat{J} = \mat{H} \dvec{q}</span>
<span class="sd">        and :math:`\mat{H} \in \mathbb{R}^{6\times n \times n}` is the</span>
<span class="sd">        Hessian tensor.</span>

<span class="sd">        The elements of the Hessian are</span>
<span class="sd">        .. math::</span>
<span class="sd">            \mat{H}_{i,j,k} =  \frac{d^2 u_i}{d q_j d q_k}</span>
<span class="sd">        where :math:`u = \{t_x, t_y, t_z, r_x, r_y, r_z\}` are the elements</span>
<span class="sd">        of the spatial velocity vector.</span>

<span class="sd">        Similarly, we can write</span>
<span class="sd">        .. math::</span>
<span class="sd">            \mat{J}_{i,j} = \frac{d u_i}{d q_j}</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example makes a ``Panda`` robot object, and solves for the</span>
<span class="sd">        end-effector frame Hessian at the given joint angle configuration</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; panda.hessiane([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="c1"># Use c extension</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS_hessiane</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">Je</span><span class="p">,</span> <span class="n">tool</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">])</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>

        <span class="k">if</span> <span class="n">Je</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">Je</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobe</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">verifymatrix</span><span class="p">(</span><span class="n">Je</span><span class="p">,</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">Je</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">Je</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
                <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cross</span><span class="p">(</span><span class="n">Je</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">j</span><span class="p">],</span> <span class="n">Je</span><span class="p">[</span><span class="mi">3</span><span class="p">:,</span> <span class="n">i</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">H</span></div>

    <span class="k">def</span> <span class="nf">jacob0_analytical</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">representation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rpy/xyz&quot;</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator analytical Jacobian in the base frame</span>

<span class="sd">        ``robot.jacob0_analytical(q)`` is the manipulator Jacobian matrix which maps</span>
<span class="sd">        joint  velocity to end-effector spatial velocity expressed in the</span>
<span class="sd">        base frame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            Joint coordinate vector</span>
<span class="sd">        representation</span>
<span class="sd">            angular representation</span>
<span class="sd">        tool</span>
<span class="sd">            a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jacob0</span>
<span class="sd">            Manipulator Jacobian in the base frame</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        End-effector spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x, \omega_y, \omega_z)^T`</span>
<span class="sd">        is related to joint velocity by :math:`{}^{E}\!\nu = \mathbf{J}_m(q) \dot{q}`.</span>

<span class="sd">        |``representation``   |       Rotational representation     |</span>
<span class="sd">        |---------------------|-------------------------------------|</span>
<span class="sd">        |``&#39;rpy/xyz&#39;``        |   RPY angular rates in XYZ order    |</span>
<span class="sd">        |``&#39;rpy/zyx&#39;``        |   RPY angular rates in XYZ order    |</span>
<span class="sd">        |``&#39;eul&#39;``            |   Euler angular rates in ZYZ order  |</span>
<span class="sd">        |``&#39;exp&#39;``            |   exponential coordinate rates      |</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Makes a robot object and computes the analytic Jacobian for the given</span>
<span class="sd">        joint configuration</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; puma = rtb.models.ETS.Puma560().ets()</span>
<span class="sd">        &gt;&gt;&gt; puma.jacob0_analytical([0, 0, 0, 0, 0, 0])</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">tool</span><span class="o">=</span><span class="n">tool</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">rotvelxform</span><span class="p">(</span><span class="n">t2r</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="n">representation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span> <span class="o">@</span> <span class="n">J</span>

    <span class="k">def</span> <span class="nf">jacobm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The manipulability Jacobian</span>

<span class="sd">        This measure relates the rate of change of the manipulability to the</span>
<span class="sd">        joint velocities of the robot. One of J or q is required. Supply J</span>
<span class="sd">        and H if already calculated to save computation time</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            The joint angles/configuration of the robot (Optional,</span>
<span class="sd">            if not supplied will use the stored q values).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        jacobm</span>
<span class="sd">            The manipulability Jacobian</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        Yoshikawa&#39;s manipulability measure</span>

<span class="sd">        .. math::</span>

<span class="sd">            m(\vec{q}) = \sqrt{\mat{J}(\vec{q}) \mat{J}(\vec{q})^T}</span>

<span class="sd">        This method returns its Jacobian with respect to configuration</span>

<span class="sd">        .. math::</span>

<span class="sd">            \frac{\partial m(\vec{q})}{\partial \vec{q}}</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hessian0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="n">manipulability</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">manipulability</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="c1"># J = J[axes, :]</span>
        <span class="c1"># H = H[:, axes, :]</span>

        <span class="n">b</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">J</span> <span class="o">@</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">Jm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">J</span> <span class="o">@</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span>
            <span class="n">Jm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">manipulability</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">b</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Jm</span>

    <span class="k">def</span> <span class="nf">manipulability</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">L</span><span class="p">[</span><span class="s2">&quot;yoshikawa&quot;</span><span class="p">,</span> <span class="s2">&quot;minsingular&quot;</span><span class="p">,</span> <span class="s2">&quot;invcondition&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;yoshikawa&quot;</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;trans&quot;</span><span class="p">,</span> <span class="s2">&quot;rot&quot;</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulability measure</span>

<span class="sd">        ``manipulability(q)`` is the scalar manipulability index</span>
<span class="sd">        for the ets at the joint configuration ``q``.  It indicates</span>
<span class="sd">        dexterity, that is, how well conditioned the ets is for motion</span>
<span class="sd">        with respect to the 6 degrees of Cartesian motion.  The values is</span>
<span class="sd">        zero if the ets is at a singularity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            Joint coordinates, one of J or q required</span>
<span class="sd">        method</span>
<span class="sd">            method to use, &quot;yoshikawa&quot; (default), &quot;invcondition&quot;,</span>
<span class="sd">            &quot;minsingular&quot;</span>
<span class="sd">        axes</span>
<span class="sd">            Task space axes to consider: &quot;all&quot; [default],</span>
<span class="sd">            &quot;trans&quot;, or &quot;rot&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        manipulability</span>
<span class="sd">            the manipulability metric</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>

<span class="sd">        Various measures are supported:</span>

<span class="sd">        | Measure           |       Description                               |</span>
<span class="sd">        |-------------------|-------------------------------------------------|</span>
<span class="sd">        | ``&quot;yoshikawa&quot;``   | Volume of the velocity ellipsoid, *distance*    |</span>
<span class="sd">        |                   | from singularity [Yoshikawa85]_                 |</span>
<span class="sd">        | ``&quot;invcondition&quot;``| Inverse condition number of Jacobian, isotropy  |</span>
<span class="sd">        |                   | of the velocity ellipsoid [Klein87]_            |</span>
<span class="sd">        | ``&quot;minsingular&quot;`` | Minimum singular value of the Jacobian,         |</span>
<span class="sd">        |                   | *distance*  from singularity [Klein87]_         |</span>

<span class="sd">        **Trajectory operation**:</span>

<span class="sd">        If ``q`` is a matrix (m,n) then the result (m,) is a vector of</span>
<span class="sd">        manipulability indices for each joint configuration specified by a row</span>
<span class="sd">        of ``q``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        - Invokes the ``jacob0`` method of the robot if ``J`` is not passed</span>
<span class="sd">        - The &quot;all&quot; option includes rotational and translational</span>
<span class="sd">            dexterity, but this involves adding different units. It can be</span>
<span class="sd">            more useful to look at the translational and rotational</span>
<span class="sd">            manipulability separately.</span>
<span class="sd">        - Examples in the RVC book (1st edition) can be replicated by</span>
<span class="sd">            using the &quot;all&quot; option</span>
<span class="sd">        - Asada&#39;s measure requires inertial a robot model with inertial</span>
<span class="sd">            parameters.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [Yoshikawa85] Manipulability of Robotic Mechanisms. Yoshikawa T.,</span>
<span class="sd">                The International Journal of Robotics Research.</span>
<span class="sd">                1985;4(2):3-9. doi:10.1177/027836498500400201</span>
<span class="sd">        .. [Klein87] Dexterity Measures for the Design and Control of</span>
<span class="sd">                Kinematically Redundant Manipulators. Klein CA, Blaho BE.</span>
<span class="sd">                The International Journal of Robotics Research.</span>
<span class="sd">                1987;6(2):72-83. doi:10.1177/027836498700600206</span>
<span class="sd">        - Robotics, Vision &amp; Control in Python, 3e, P. Corke, Springer 2023, Chap 7.</span>


<span class="sd">        .. versionchanged:: 1.0.4</span>
<span class="sd">            Removed &#39;both&#39; option for axes, added a custom list option.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">axes_list</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">axes_list</span> <span class="o">=</span> <span class="n">axes</span>
        <span class="k">elif</span> <span class="n">axes</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
            <span class="n">axes_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axes</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;trans&quot;</span><span class="p">):</span>
            <span class="n">axes_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axes</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;rot&quot;</span><span class="p">):</span>
            <span class="n">axes_list</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axes must be all, trans, rot or both&quot;</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">yoshikawa</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">axes</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">J</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># simplified case for square matrix</span>
                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">det</span><span class="p">(</span><span class="n">J</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m2</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">J</span> <span class="o">@</span> <span class="n">J</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m2</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">condition</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">axes</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">cond</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">minsingular</span><span class="p">(</span><span class="n">robot</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">J</span> <span class="o">=</span> <span class="n">J</span><span class="p">[</span><span class="n">axes</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># return last/smallest singular value of J</span>

        <span class="c1"># choose the handler function</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;yoshikawa&quot;</span><span class="p">:</span>
            <span class="n">mfunc</span> <span class="o">=</span> <span class="n">yoshikawa</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;invcondition&quot;</span><span class="p">:</span>
            <span class="n">mfunc</span> <span class="o">=</span> <span class="n">condition</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;minsingular&quot;</span><span class="p">:</span>
            <span class="n">mfunc</span> <span class="o">=</span> <span class="n">minsingular</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid method chosen&quot;</span><span class="p">)</span>

        <span class="c1"># Otherwise use the q vector/matrix</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">getmatrix</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)))</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">q</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">qk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
            <span class="n">Jk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>
            <span class="n">w</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">mfunc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Jk</span><span class="p">,</span> <span class="n">qk</span><span class="p">,</span> <span class="n">axes_list</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">w</span>

    <span class="k">def</span> <span class="nf">partial_fkine0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Manipulator Forward Kinematics nth Partial Derivative</span>

<span class="sd">        This method computes the nth derivative of the forward kinematics where ``n`` is</span>
<span class="sd">        greater than or equal to 3. This is an extension of the differential kinematics</span>
<span class="sd">        where the Jacobian is the first partial derivative and the Hessian is the</span>
<span class="sd">        second.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q</span>
<span class="sd">            The joint angles/configuration of the robot (Optional,</span>
<span class="sd">            if not supplied will use the stored q values).</span>
<span class="sd">        end</span>
<span class="sd">            the final link/Gripper which the Hessian represents</span>
<span class="sd">        start</span>
<span class="sd">            the first link which the Hessian represents</span>
<span class="sd">        tool</span>
<span class="sd">            a static tool transformation matrix to apply to the</span>
<span class="sd">            end of end, defaults to None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A</span>
<span class="sd">            The nth Partial Derivative of the forward kinematics</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example makes a ``Panda`` robot object, and solves for the</span>
<span class="sd">        base-effector frame 4th defivative of the forward kinematics at the given</span>
<span class="sd">        joint angle configuration</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; panda.partial_fkine0([0, -0.3, 0, -2.2, 0, 2, 0.7854], n=4)</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="c1"># Calculate the Jacobian and Hessian</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hessian0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="c1"># A list of derivatives, starting with the jacobian and hessian</span>
        <span class="n">dT</span> <span class="o">=</span> <span class="p">[</span><span class="n">J</span><span class="p">,</span> <span class="n">H</span><span class="p">]</span>

        <span class="c1"># The tensor dimensions of the latest derivative</span>
        <span class="c1"># Set to the current size of the Hessian</span>
        <span class="n">size</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">]</span>

        <span class="c1"># An array which keeps track of the index of the partial derivative</span>
        <span class="c1"># we are calculating</span>
        <span class="c1"># It stores the indices in the order: &quot;j, k, l. m, n, o, ...&quot;</span>
        <span class="c1"># where count is extended to match oder of the partial derivative</span>
        <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># The order of derivative for which we are calculating</span>
        <span class="c1"># The Hessian is the 2nd-order so we start with c = 2</span>
        <span class="n">c</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">def</span> <span class="nf">add_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
            <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">new_indices</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">new_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">new_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="n">new_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># if even number</span>
                    <span class="n">new_indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if odd number</span>
                    <span class="n">new_indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">new_indices</span>

        <span class="k">def</span> <span class="nf">add_pdi</span><span class="p">(</span><span class="n">pdi</span><span class="p">):</span>
            <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pdi</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">new_pdi</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="n">new_pdi</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
                <span class="n">new_pdi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pdi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">new_pdi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pdi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                <span class="c1"># if even number</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_pdi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># if odd number</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_pdi</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">new_pdi</span>

        <span class="c1"># these are the indices used for the hessian</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>

        <span class="c1"># The partial derivative indices (pdi)</span>
        <span class="c1"># the are the pd indices used in the cross products</span>
        <span class="n">pdi</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># The length of dT correspods to the number of derivatives we have calculated</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">dT</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="c1"># Add to the start of the tensor size list</span>
            <span class="n">size</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">)</span>

            <span class="c1"># Add an axis to the count array</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mi">0</span><span class="p">],</span> <span class="n">count</span><span class="p">))</span>

            <span class="c1"># This variables corresponds to indices within the previous</span>
            <span class="c1"># partial derivatives</span>
            <span class="c1"># to be cross prodded</span>
            <span class="c1"># The order is: &quot;[j, k, l, m, n, o, ...]&quot;</span>
            <span class="c1"># Although, our partial derivatives have the order:</span>
            <span class="c1"># pd[..., o, n, m, l, k, cartesian DoF, j]</span>
            <span class="c1"># For example, consider the Hessian Tensor H[n, 6, n],</span>
            <span class="c1"># the index H[k, :, j]. This corrsponds</span>
            <span class="c1"># to the second partial derivative of the kinematics of joint j with</span>
            <span class="c1"># respect to joint k.</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">add_indices</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

            <span class="c1"># This variable corresponds to the indices in Td which corresponds to the</span>
            <span class="c1"># partial derivatives we need to use</span>
            <span class="n">pdi</span> <span class="o">=</span> <span class="n">add_pdi</span><span class="p">(</span><span class="n">pdi</span><span class="p">)</span>

            <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Allocate our new partial derivative tensor</span>
            <span class="n">pd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

            <span class="c1"># We need to loop n^c times</span>
            <span class="c1"># There are n^c columns to calculate</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="o">**</span><span class="n">c</span><span class="p">):</span>
                <span class="c1"># Allocate the rotation and translation components</span>
                <span class="n">rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                <span class="n">trn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

                <span class="c1"># This loop calculates a single column ([trn, rot])</span>
                <span class="c1"># of the tensor for dT(x)</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
                    <span class="n">pdr0</span> <span class="o">=</span> <span class="n">dT</span><span class="p">[</span><span class="n">pdi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">pdr1</span> <span class="o">=</span> <span class="n">dT</span><span class="p">[</span><span class="n">pdi</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>

                    <span class="n">idx0</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">idx1</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>

                    <span class="c1"># This is a list of indices selecting the slices of the</span>
                    <span class="c1"># previous tensor</span>
                    <span class="n">idx0_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">idx0</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">idx1_slices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">idx1</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

                    <span class="c1"># This index selecting the column within the 2d slice of the</span>
                    <span class="c1"># previous tensor</span>
                    <span class="n">idx0_n</span> <span class="o">=</span> <span class="n">idx0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">idx1_n</span> <span class="o">=</span> <span class="n">idx1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># Use our indices to select the rotational column from pdr0 and pdr1</span>
                    <span class="n">col0_rot</span> <span class="o">=</span> <span class="n">pdr0</span><span class="p">[(</span><span class="o">*</span><span class="n">idx0_slices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">idx0_n</span><span class="p">)]</span>
                    <span class="n">col1_rot</span> <span class="o">=</span> <span class="n">pdr1</span><span class="p">[(</span><span class="o">*</span><span class="n">idx1_slices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">idx1_n</span><span class="p">)]</span>

                    <span class="c1"># Use our indices to select the translational column from pdr1</span>
                    <span class="n">col1_trn</span> <span class="o">=</span> <span class="n">pdr1</span><span class="p">[(</span><span class="o">*</span><span class="n">idx1_slices</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">idx1_n</span><span class="p">)]</span>

                    <span class="c1"># Perform the cross product as described in the maths above</span>
                    <span class="n">rot</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">col0_rot</span><span class="p">,</span> <span class="n">col1_rot</span><span class="p">)</span>
                    <span class="n">trn</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">col0_rot</span><span class="p">,</span> <span class="n">col1_trn</span><span class="p">)</span>

                <span class="n">pd</span><span class="p">[(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">trn</span>
                <span class="n">pd</span><span class="p">[(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">rot</span>

                <span class="n">count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">count</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
                        <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">count</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">dT</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dT</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<div class="viewcode-block" id="ETS.ik_LM"><a class="viewcode-back" href="../../../IK/stubs/roboticstoolbox.robot.ETS.ETS.ik_LM.html#roboticstoolbox.robot.ETS.ETS.ik_LM">[docs]</a>    <span class="k">def</span> <span class="nf">ik_LM</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">joint_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">L</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">,</span> <span class="s2">&quot;wampler&quot;</span><span class="p">,</span> <span class="s2">&quot;sugihara&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;chan&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast levenberg-Marquadt Numerical Inverse Kinematics Solver</span>

<span class="sd">        A method which provides functionality to perform numerical inverse kinematics (IK)</span>
<span class="sd">        using the Levemberg-Marquadt method. This</span>
<span class="sd">        is a fast solver implemented in C++.</span>

<span class="sd">        See the :ref:`Inverse Kinematics Docs Page &lt;IK&gt;` for more details and for a</span>
<span class="sd">        **tutorial** on numerical IK, see `here &lt;https://bit.ly/3ak5GDi&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tep</span>
<span class="sd">            The desired end-effector pose</span>
<span class="sd">        q0</span>
<span class="sd">            The initial joint coordinate vector</span>
<span class="sd">        ilimit</span>
<span class="sd">            How many iterations are allowed within a search before a new search</span>
<span class="sd">            is started</span>
<span class="sd">        slimit</span>
<span class="sd">            How many searches are allowed before being deemed unsuccessful</span>
<span class="sd">        tol</span>
<span class="sd">            Maximum allowed residual error E</span>
<span class="sd">        mask</span>
<span class="sd">            A 6 vector which assigns weights to Cartesian degrees-of-freedom</span>
<span class="sd">            error priority</span>
<span class="sd">        joint_limits</span>
<span class="sd">            Reject solutions with joint limit violations</span>
<span class="sd">        seed</span>
<span class="sd">            A seed for the private RNG used to generate random joint coordinate</span>
<span class="sd">            vectors</span>
<span class="sd">        k</span>
<span class="sd">            Sets the gain value for the damping matrix Wn in the next iteration. See</span>
<span class="sd">            synopsis</span>
<span class="sd">        method</span>
<span class="sd">            One of &quot;chan&quot;, &quot;sugihara&quot; or &quot;wampler&quot;. Defines which method is used</span>
<span class="sd">            to calculate the damping matrix Wn in the ``step`` method</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        The operation is defined by the choice of the ``method`` kwarg.</span>

<span class="sd">        The step is deined as</span>

<span class="sd">        .. math::</span>

<span class="sd">            \vec{q}_{k+1}</span>
<span class="sd">            &amp;=</span>
<span class="sd">            \vec{q}_k +</span>
<span class="sd">            \left(</span>
<span class="sd">                \mat{A}_k</span>
<span class="sd">            \right)^{-1}</span>
<span class="sd">            \bf{g}_k \\</span>
<span class="sd">            %</span>
<span class="sd">            \mat{A}_k</span>
<span class="sd">            &amp;=</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}^\top</span>
<span class="sd">            \mat{W}_e \</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}</span>
<span class="sd">            +</span>
<span class="sd">            \mat{W}_n</span>

<span class="sd">        where :math:`\mat{W}_n = \text{diag}(\vec{w_n})(\vec{w_n} \in \mathbb{R}^n_{&gt;0})` is a</span>
<span class="sd">        diagonal damping matrix. The damping matrix ensures that :math:`\mat{A}_k` is</span>
<span class="sd">        non-singular and positive definite. The performance of the LM method largely depends</span>
<span class="sd">        on the choice of :math:`\mat{W}_n`.</span>

<span class="sd">        *Chan&#39;s Method*</span>

<span class="sd">        Chan proposed</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mat{W}_n</span>
<span class="sd">            =</span>
<span class="sd">            Œª E_k \mat{1}_n</span>

<span class="sd">        where Œª is a constant which reportedly does not have much influence on performance.</span>
<span class="sd">        Use the kwarg `k` to adjust the weighting term Œª.</span>

<span class="sd">        *Sugihara&#39;s Method*</span>

<span class="sd">        Sugihara proposed</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mat{W}_n</span>
<span class="sd">            =</span>
<span class="sd">            E_k \mat{1}_n + \text{diag}(\hat{\vec{w}}_n)</span>

<span class="sd">        where :math:`\hat{\vec{w}}_n \in \mathbb{R}^n`, :math:`\hat{w}_{n_i} = l^2 \sim 0.01 l^2`,</span>
<span class="sd">        and :math:`l` is the length of a typical link within the manipulator. We provide the</span>
<span class="sd">        variable `k` as a kwarg to adjust the value of :math:`w_n`.</span>

<span class="sd">        *Wampler&#39;s Method*</span>

<span class="sd">        Wampler proposed :math:`\vec{w_n}` to be a constant. This is set through the `k` kwarg.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example gets the ``ets`` of a ``panda`` robot object, makes a goal</span>
<span class="sd">        pose ``Tep``, and then solves for the joint coordinates which result in the pose</span>
<span class="sd">        ``Tep`` using the `ikine_LM` method.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; Tep = panda.fkine([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>
<span class="sd">        &gt;&gt;&gt; panda.ikine_LM(Tep)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The value for the ``k`` kwarg will depend on the ``method`` chosen and the arm you are</span>
<span class="sd">        using. Use the following as a rough guide ``chan, k = 1.0 - 0.01``,</span>
<span class="sd">        ``wampler, k = 0.01 - 0.0001``, and ``sugihara, k = 0.1 - 0.0001``</span>

<span class="sd">        When using the this method, the initial joint coordinates :math:`q_0`, should correspond</span>
<span class="sd">        to a non-singular manipulator pose, since it uses the manipulator Jacobian.</span>

<span class="sd">        This class supports null-space motion to assist with maximising manipulability and</span>
<span class="sd">        avoiding joint limits. These are enabled by setting kq and km to non-zero values.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ik_NR</span>
<span class="sd">            A fast numerical inverse kinematics solver using Newton-Raphson optimisation</span>
<span class="sd">        ik_GN</span>
<span class="sd">            A fast numerical inverse kinematics solver using Gauss-Newton optimisation</span>


<span class="sd">        .. versionchanged:: 1.0.4</span>
<span class="sd">            Merged the Levemberg-Marquadt IK solvers into the ik_LM method</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="k">return</span> <span class="n">IK_LM_c</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span> <span class="n">Tep</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">ilimit</span><span class="p">,</span> <span class="n">slimit</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">joint_limits</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">method</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ETS.ik_NR"><a class="viewcode-back" href="../../../IK/stubs/roboticstoolbox.robot.ETS.ETS.ik_nr.html#roboticstoolbox.robot.ETS.ETS.ik_NR">[docs]</a>    <span class="k">def</span> <span class="nf">ik_NR</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">joint_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pinv</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pinv_damping</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast numerical inverse kinematics using Newton-Raphson optimization</span>

<span class="sd">        ``sol = ets.ik_NR(Tep)`` are the joint coordinates (n) corresponding</span>
<span class="sd">        to the robot end-effector pose ``Tep`` which is an ``SE3`` or ``ndarray`` object.</span>
<span class="sd">        This method can be used for robots with any number of degrees of freedom. This</span>
<span class="sd">        is a fast solver implemented in C++.</span>

<span class="sd">        See the :ref:`Inverse Kinematics Docs Page &lt;IK&gt;` for more details and for a</span>
<span class="sd">        **tutorial** on numerical IK, see `here &lt;https://bit.ly/3ak5GDi&gt;`_.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        When using this method with redundant robots (&gt;6 DoF), ``pinv`` must be set to ``True``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tep</span>
<span class="sd">            The desired end-effector pose or pose trajectory</span>
<span class="sd">        q0</span>
<span class="sd">            initial joint configuration (default to random valid joint</span>
<span class="sd">            configuration contrained by the joint limits of the robot)</span>
<span class="sd">        ilimit</span>
<span class="sd">            maximum number of iterations per search</span>
<span class="sd">        slimit</span>
<span class="sd">            maximum number of search attempts</span>
<span class="sd">        tol</span>
<span class="sd">            final error tolerance</span>
<span class="sd">        mask</span>
<span class="sd">            a mask vector which weights the end-effector error priority.</span>
<span class="sd">            Corresponds to translation in X, Y and Z and rotation about X, Y and Z</span>
<span class="sd">            respectively</span>
<span class="sd">        joint_limits</span>
<span class="sd">            constrain the solution to being within the joint limits of</span>
<span class="sd">            the robot (reject solution with invalid joint configurations and perfrom</span>
<span class="sd">            another search up to the slimit)</span>
<span class="sd">        pinv</span>
<span class="sd">            Use the psuedo-inverse instad of the normal matrix inverse</span>
<span class="sd">        pinv_damping</span>
<span class="sd">            Damping factor for the psuedo-inverse</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sol</span>
<span class="sd">            tuple (q, success, iterations, searches, residual)</span>

<span class="sd">        The return value ``sol`` is a tuple with elements:</span>

<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        Element         Type        Description</span>
<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        ``q``           ndarray(n)  joint coordinates in units of radians or metres</span>
<span class="sd">        ``success``     int         whether a solution was found</span>
<span class="sd">        ``iterations``  int         total number of iterations</span>
<span class="sd">        ``searches``    int         total number of searches</span>
<span class="sd">        ``residual``    float       final value of cost function</span>
<span class="sd">        ============    ==========  ===============================================</span>

<span class="sd">        If ``success == 0`` the ``q`` values will be valid numbers, but the</span>
<span class="sd">        solution will be in error.  The amount of error is indicated by</span>
<span class="sd">        the ``residual``.</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        Each iteration uses the Newton-Raphson optimisation method</span>

<span class="sd">        .. math::</span>

<span class="sd">            \vec{q}_{k+1} = \vec{q}_k + {^0\mat{J}(\vec{q}_k)}^{-1} \vec{e}_k</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example gets the ``ets`` of a ``panda`` robot object, makes a goal</span>
<span class="sd">        pose ``Tep``, and then solves for the joint coordinates which result in the pose</span>
<span class="sd">        ``Tep`` using the `ikine_GN` method.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; Tep = panda.fkine([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>
<span class="sd">        &gt;&gt;&gt; panda.ik_NR(Tep)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When using the this method, the initial joint coordinates :math:`q_0`, should correspond</span>
<span class="sd">        to a non-singular manipulator pose, since it uses the manipulator Jacobian.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ik_LM</span>
<span class="sd">            A fast numerical inverse kinematics solver using Levenberg-Marquadt optimisation</span>
<span class="sd">        ik_GN</span>
<span class="sd">            A fast numerical inverse kinematics solver using Gauss-Newton optimisation</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="k">return</span> <span class="n">IK_NR_c</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span>
            <span class="n">Tep</span><span class="p">,</span>
            <span class="n">q0</span><span class="p">,</span>
            <span class="n">ilimit</span><span class="p">,</span>
            <span class="n">slimit</span><span class="p">,</span>
            <span class="n">tol</span><span class="p">,</span>
            <span class="n">joint_limits</span><span class="p">,</span>
            <span class="n">mask</span><span class="p">,</span>
            <span class="n">pinv</span><span class="p">,</span>
            <span class="n">pinv_damping</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ETS.ik_GN"><a class="viewcode-back" href="../../../IK/stubs/roboticstoolbox.robot.ETS.ETS.ik_gn.html#roboticstoolbox.robot.ETS.ETS.ik_GN">[docs]</a>    <span class="k">def</span> <span class="nf">ik_GN</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">joint_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pinv</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">pinv_damping</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fast numerical inverse kinematics by Gauss-Newton optimization</span>

<span class="sd">        ``sol = ets.ik_GN(Tep)`` are the joint coordinates (n) corresponding</span>
<span class="sd">        to the robot end-effector pose ``Tep`` which is an ``SE3`` or ``ndarray`` object.</span>
<span class="sd">        This method can be used for robots with any number of degrees of freedom. This</span>
<span class="sd">        is a fast solver implemented in C++.</span>

<span class="sd">        See the :ref:`Inverse Kinematics Docs Page &lt;IK&gt;` for more details and for a</span>
<span class="sd">        **tutorial** on numerical IK, see `here &lt;https://bit.ly/3ak5GDi&gt;`_.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        When using this method with redundant robots (&gt;6 DoF), ``pinv`` must be set to ``True``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tep</span>
<span class="sd">            The desired end-effector pose or pose trajectory</span>
<span class="sd">        q0</span>
<span class="sd">            initial joint configuration (default to random valid joint</span>
<span class="sd">            configuration contrained by the joint limits of the robot)</span>
<span class="sd">        ilimit</span>
<span class="sd">            maximum number of iterations per search</span>
<span class="sd">        slimit</span>
<span class="sd">            maximum number of search attempts</span>
<span class="sd">        tol</span>
<span class="sd">            final error tolerance</span>
<span class="sd">        mask</span>
<span class="sd">            a mask vector which weights the end-effector error priority.</span>
<span class="sd">            Corresponds to translation in X, Y and Z and rotation about X, Y and Z</span>
<span class="sd">            respectively</span>
<span class="sd">        joint_limits</span>
<span class="sd">            constrain the solution to being within the joint limits of</span>
<span class="sd">            the robot (reject solution with invalid joint configurations and perfrom</span>
<span class="sd">            another search up to the slimit)</span>
<span class="sd">        pinv</span>
<span class="sd">            Use the psuedo-inverse instad of the normal matrix inverse</span>
<span class="sd">        pinv_damping</span>
<span class="sd">            Damping factor for the psuedo-inverse</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sol</span>
<span class="sd">            tuple (q, success, iterations, searches, residual)</span>

<span class="sd">        The return value ``sol`` is a tuple with elements:</span>

<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        Element         Type        Description</span>
<span class="sd">        ============    ==========  ===============================================</span>
<span class="sd">        ``q``           ndarray(n)  joint coordinates in units of radians or metres</span>
<span class="sd">        ``success``     int         whether a solution was found</span>
<span class="sd">        ``iterations``  int         total number of iterations</span>
<span class="sd">        ``searches``    int         total number of searches</span>
<span class="sd">        ``residual``    float       final value of cost function</span>
<span class="sd">        ============    ==========  ===============================================</span>

<span class="sd">        If ``success == 0`` the ``q`` values will be valid numbers, but the</span>
<span class="sd">        solution will be in error.  The amount of error is indicated by</span>
<span class="sd">        the ``residual``.</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        Each iteration uses the Gauss-Newton optimisation method</span>

<span class="sd">        .. math::</span>

<span class="sd">            \vec{q}_{k+1} &amp;= \vec{q}_k +</span>
<span class="sd">            \left(</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}^\top</span>
<span class="sd">            \mat{W}_e \</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}</span>
<span class="sd">            \right)^{-1}</span>
<span class="sd">            \bf{g}_k \\</span>
<span class="sd">            \bf{g}_k &amp;=</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}^\top</span>
<span class="sd">            \mat{W}_e</span>
<span class="sd">            \vec{e}_k</span>

<span class="sd">        where :math:`\mat{J} = {^0\mat{J}}` is the base-frame manipulator Jacobian. If</span>
<span class="sd">        :math:`\mat{J}(\vec{q}_k)` is non-singular, and :math:`\mat{W}_e = \mat{1}_n`, then</span>
<span class="sd">        the above provides the pseudoinverse solution. However, if :math:`\mat{J}(\vec{q}_k)`</span>
<span class="sd">        is singular, the above can not be computed and the GN solution is infeasible.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example gets the ``ets`` of a ``panda`` robot object, makes a goal</span>
<span class="sd">        pose ``Tep``, and then solves for the joint coordinates which result in the pose</span>
<span class="sd">        ``Tep`` using the `ikine_GN` method.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; Tep = panda.fkine([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>
<span class="sd">        &gt;&gt;&gt; panda.ik_GN(Tep)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When using the this method, the initial joint coordinates :math:`q_0`, should correspond</span>
<span class="sd">        to a non-singular manipulator pose, since it uses the manipulator Jacobian.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ik_NR</span>
<span class="sd">            A fast numerical inverse kinematics solver using Newton-Raphson optimisation</span>
<span class="sd">        ik_GN</span>
<span class="sd">            A fast numerical inverse kinematics solver using Gauss-Newton optimisation</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="k">return</span> <span class="n">IK_GN_c</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fknm</span><span class="p">,</span>
            <span class="n">Tep</span><span class="p">,</span>
            <span class="n">q0</span><span class="p">,</span>
            <span class="n">ilimit</span><span class="p">,</span>
            <span class="n">slimit</span><span class="p">,</span>
            <span class="n">tol</span><span class="p">,</span>
            <span class="n">joint_limits</span><span class="p">,</span>
            <span class="n">mask</span><span class="p">,</span>
            <span class="n">pinv</span><span class="p">,</span>
            <span class="n">pinv_damping</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="ETS.ikine_LM"><a class="viewcode-back" href="../../../IK/stubs/roboticstoolbox.robot.ETS.ETS.ikine_LM.html#roboticstoolbox.robot.ETS.ETS.ikine_LM">[docs]</a>    <span class="k">def</span> <span class="nf">ikine_LM</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">joint_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">L</span><span class="p">[</span><span class="s2">&quot;chan&quot;</span><span class="p">,</span> <span class="s2">&quot;wampler&quot;</span><span class="p">,</span> <span class="s2">&quot;sugihara&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;chan&quot;</span><span class="p">,</span>
        <span class="n">kq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">km</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">ps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">pi</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Levemberg-Marquadt Numerical Inverse Kinematics Solver</span>

<span class="sd">        A method which provides functionality to perform numerical inverse kinematics (IK)</span>
<span class="sd">        using the Levemberg-Marquadt method.</span>

<span class="sd">        See the :ref:`Inverse Kinematics Docs Page &lt;IK&gt;` for more details and for a </span>
<span class="sd">        **tutorial** on numerical IK, see `here &lt;https://bit.ly/3ak5GDi&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tep</span>
<span class="sd">            The desired end-effector pose</span>
<span class="sd">        q0</span>
<span class="sd">            The initial joint coordinate vector</span>
<span class="sd">        ilimit</span>
<span class="sd">            How many iterations are allowed within a search before a new search</span>
<span class="sd">            is started</span>
<span class="sd">        slimit</span>
<span class="sd">            How many searches are allowed before being deemed unsuccessful</span>
<span class="sd">        tol</span>
<span class="sd">            Maximum allowed residual error E</span>
<span class="sd">        mask</span>
<span class="sd">            A 6 vector which assigns weights to Cartesian degrees-of-freedom</span>
<span class="sd">            error priority</span>
<span class="sd">        joint_limits</span>
<span class="sd">            Reject solutions with joint limit violations</span>
<span class="sd">        seed</span>
<span class="sd">            A seed for the private RNG used to generate random joint coordinate</span>
<span class="sd">            vectors</span>
<span class="sd">        k</span>
<span class="sd">            Sets the gain value for the damping matrix Wn in the next iteration. See</span>
<span class="sd">            synopsis</span>
<span class="sd">        method</span>
<span class="sd">            One of &quot;chan&quot;, &quot;sugihara&quot; or &quot;wampler&quot;. Defines which method is used</span>
<span class="sd">            to calculate the damping matrix Wn in the ``step`` method</span>
<span class="sd">        kq</span>
<span class="sd">            The gain for joint limit avoidance. Setting to 0.0 will remove this</span>
<span class="sd">            completely from the solution</span>
<span class="sd">        km</span>
<span class="sd">            The gain for maximisation. Setting to 0.0 will remove this completely</span>
<span class="sd">            from the solution</span>
<span class="sd">        ps</span>
<span class="sd">            The minimum angle/distance (in radians or metres) in which the joint is</span>
<span class="sd">            allowed to approach to its limit</span>
<span class="sd">        pi</span>
<span class="sd">            The influence angle/distance (in radians or metres) in null space motion</span>
<span class="sd">            becomes active</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        The operation is defined by the choice of the ``method`` kwarg. </span>

<span class="sd">        The step is deined as</span>

<span class="sd">        .. math::</span>

<span class="sd">            \vec{q}_{k+1} </span>
<span class="sd">            &amp;= </span>
<span class="sd">            \vec{q}_k +</span>
<span class="sd">            \left(</span>
<span class="sd">                \mat{A}_k</span>
<span class="sd">            \right)^{-1}</span>
<span class="sd">            \bf{g}_k \\</span>
<span class="sd">            %</span>
<span class="sd">            \mat{A}_k</span>
<span class="sd">            &amp;=</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}^\top</span>
<span class="sd">            \mat{W}_e \</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}</span>
<span class="sd">            +</span>
<span class="sd">            \mat{W}_n</span>

<span class="sd">        where :math:`\mat{W}_n = \text{diag}(\vec{w_n})(\vec{w_n} \in \mathbb{R}^n_{&gt;0})` is a</span>
<span class="sd">        diagonal damping matrix. The damping matrix ensures that :math:`\mat{A}_k` is</span>
<span class="sd">        non-singular and positive definite. The performance of the LM method largely depends</span>
<span class="sd">        on the choice of :math:`\mat{W}_n`.</span>

<span class="sd">        *Chan&#39;s Method*</span>

<span class="sd">        Chan proposed</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mat{W}_n</span>
<span class="sd">            =</span>
<span class="sd">            Œª E_k \mat{1}_n</span>

<span class="sd">        where Œª is a constant which reportedly does not have much influence on performance.</span>
<span class="sd">        Use the kwarg `k` to adjust the weighting term Œª.</span>

<span class="sd">        *Sugihara&#39;s Method*</span>

<span class="sd">        Sugihara proposed</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mat{W}_n</span>
<span class="sd">            =</span>
<span class="sd">            E_k \mat{1}_n + \text{diag}(\hat{\vec{w}}_n)</span>

<span class="sd">        where :math:`\hat{\vec{w}}_n \in \mathbb{R}^n`, :math:`\hat{w}_{n_i} = l^2 \sim 0.01 l^2`,</span>
<span class="sd">        and :math:`l` is the length of a typical link within the manipulator. We provide the</span>
<span class="sd">        variable `k` as a kwarg to adjust the value of :math:`w_n`.</span>

<span class="sd">        *Wampler&#39;s Method*</span>

<span class="sd">        Wampler proposed :math:`\vec{w_n}` to be a constant. This is set through the `k` kwarg.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example gets the ``ets`` of a ``panda`` robot object, makes a goal</span>
<span class="sd">        pose ``Tep``, and then solves for the joint coordinates which result in the pose</span>
<span class="sd">        ``Tep`` using the `ikine_LM` method.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; Tep = panda.fkine([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>
<span class="sd">        &gt;&gt;&gt; panda.ikine_LM(Tep)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The value for the ``k`` kwarg will depend on the ``method`` chosen and the arm you are</span>
<span class="sd">        using. Use the following as a rough guide ``chan, k = 1.0 - 0.01``,</span>
<span class="sd">        ``wampler, k = 0.01 - 0.0001``, and ``sugihara, k = 0.1 - 0.0001``</span>
<span class="sd">        </span>
<span class="sd">        When using the this method, the initial joint coordinates :math:`q_0`, should correspond</span>
<span class="sd">        to a non-singular manipulator pose, since it uses the manipulator Jacobian.</span>

<span class="sd">        This class supports null-space motion to assist with maximising manipulability and</span>
<span class="sd">        avoiding joint limits. These are enabled by setting kq and km to non-zero values.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:class:`~roboticstoolbox.robot.IK.IK_LM`</span>
<span class="sd">            An IK Solver class which implements the Levemberg Marquadt optimisation technique</span>
<span class="sd">        ikine_NR</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_NR` class as a method within the :py:class:`ETS` class</span>
<span class="sd">        ikine_GN</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_GN` class as a method within the :py:class:`ETS` class</span>
<span class="sd">        ikine_QP</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_QP` class as a method within the :py:class:`ETS` class</span>


<span class="sd">        .. versionchanged:: 1.0.4</span>
<span class="sd">            Added the Levemberg-Marquadt IK solver method on the `ETS` class</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="n">solver</span> <span class="o">=</span> <span class="n">IK_LM</span><span class="p">(</span>
            <span class="n">ilimit</span><span class="o">=</span><span class="n">ilimit</span><span class="p">,</span>
            <span class="n">slimit</span><span class="o">=</span><span class="n">slimit</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
            <span class="n">joint_limits</span><span class="o">=</span><span class="n">joint_limits</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
            <span class="n">kq</span><span class="o">=</span><span class="n">kq</span><span class="p">,</span>
            <span class="n">km</span><span class="o">=</span><span class="n">km</span><span class="p">,</span>
            <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">,</span>
            <span class="n">pi</span><span class="o">=</span><span class="n">pi</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># if isinstance(Tep, SE3):</span>
        <span class="c1">#     Tep = Tep.A</span>

        <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">ets</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">Tep</span><span class="o">=</span><span class="n">Tep</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">q0</span><span class="p">)</span></div>

<div class="viewcode-block" id="ETS.ikine_NR"><a class="viewcode-back" href="../../../IK/stubs/roboticstoolbox.robot.ETS.ETS.ikine_NR.html#roboticstoolbox.robot.ETS.ETS.ikine_NR">[docs]</a>    <span class="k">def</span> <span class="nf">ikine_NR</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">joint_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pinv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">km</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">ps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">pi</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Newton-Raphson Numerical Inverse Kinematics Solver</span>

<span class="sd">        A method which provides functionality to perform numerical inverse kinematics (IK)</span>
<span class="sd">        using the Newton-Raphson method.</span>

<span class="sd">        See the :ref:`Inverse Kinematics Docs Page &lt;IK&gt;` for more details and for a</span>
<span class="sd">        **tutorial** on numerical IK, see `here &lt;https://bit.ly/3ak5GDi&gt;`_.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        When using this method with redundant robots (&gt;6 DoF), ``pinv`` must be set to ``True``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tep</span>
<span class="sd">            The desired end-effector pose</span>
<span class="sd">        q0</span>
<span class="sd">            The initial joint coordinate vector</span>
<span class="sd">        ilimit</span>
<span class="sd">            How many iterations are allowed within a search before a new search</span>
<span class="sd">            is started</span>
<span class="sd">        slimit</span>
<span class="sd">            How many searches are allowed before being deemed unsuccessful</span>
<span class="sd">        tol</span>
<span class="sd">            Maximum allowed residual error E</span>
<span class="sd">        mask</span>
<span class="sd">            A 6 vector which assigns weights to Cartesian degrees-of-freedom</span>
<span class="sd">            error priority</span>
<span class="sd">        joint_limits</span>
<span class="sd">            Reject solutions with joint limit violations</span>
<span class="sd">        seed</span>
<span class="sd">            A seed for the private RNG used to generate random joint coordinate</span>
<span class="sd">            vectors</span>
<span class="sd">        pinv</span>
<span class="sd">            If True, will use the psuedoinverse in the `step` method instead of</span>
<span class="sd">            the normal inverse</span>
<span class="sd">        kq</span>
<span class="sd">            The gain for joint limit avoidance. Setting to 0.0 will remove this</span>
<span class="sd">            completely from the solution</span>
<span class="sd">        km</span>
<span class="sd">            The gain for maximisation. Setting to 0.0 will remove this completely</span>
<span class="sd">            from the solution</span>
<span class="sd">        ps</span>
<span class="sd">            The minimum angle/distance (in radians or metres) in which the joint is</span>
<span class="sd">            allowed to approach to its limit</span>
<span class="sd">        pi</span>
<span class="sd">            The influence angle/distance (in radians or metres) in null space motion</span>
<span class="sd">            becomes active</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        Each iteration uses the Newton-Raphson optimisation method</span>

<span class="sd">        .. math::</span>

<span class="sd">            \vec{q}_{k+1} = \vec{q}_k + {^0\mat{J}(\vec{q}_k)}^{-1} \vec{e}_k</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example gets the ``ets`` of a ``panda`` robot object, makes a goal</span>
<span class="sd">        pose ``Tep``, and then solves for the joint coordinates which result in the pose</span>
<span class="sd">        ``Tep`` using the `ikine_NR` method.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; Tep = panda.fkine([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>
<span class="sd">        &gt;&gt;&gt; panda.ikine_NR(Tep)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When using the this method, the initial joint coordinates :math:`q_0`, should correspond</span>
<span class="sd">        to a non-singular manipulator pose, since it uses the manipulator Jacobian.</span>

<span class="sd">        This class supports null-space motion to assist with maximising manipulability and</span>
<span class="sd">        avoiding joint limits. These are enabled by setting kq and km to non-zero values.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:class:`~roboticstoolbox.robot.IK.IK_NR`</span>
<span class="sd">            An IK Solver class which implements the Newton-Raphson optimisation technique</span>
<span class="sd">        ikine_LM</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_LM` class as a method within the :py:class:`ETS` class</span>
<span class="sd">        ikine_GN</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_GN` class as a method within the :py:class:`ETS` class</span>
<span class="sd">        ikine_QP</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_QP` class as a method within the :py:class:`ETS` class</span>


<span class="sd">        .. versionchanged:: 1.0.4</span>
<span class="sd">            Added the Newton-Raphson IK solver method on the `ETS` class</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="n">solver</span> <span class="o">=</span> <span class="n">IK_NR</span><span class="p">(</span>
            <span class="n">ilimit</span><span class="o">=</span><span class="n">ilimit</span><span class="p">,</span>
            <span class="n">slimit</span><span class="o">=</span><span class="n">slimit</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
            <span class="n">joint_limits</span><span class="o">=</span><span class="n">joint_limits</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">pinv</span><span class="o">=</span><span class="n">pinv</span><span class="p">,</span>
            <span class="n">kq</span><span class="o">=</span><span class="n">kq</span><span class="p">,</span>
            <span class="n">km</span><span class="o">=</span><span class="n">km</span><span class="p">,</span>
            <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">,</span>
            <span class="n">pi</span><span class="o">=</span><span class="n">pi</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># if isinstance(Tep, SE3):</span>
        <span class="c1">#     Tep = Tep.A</span>

        <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">ets</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">Tep</span><span class="o">=</span><span class="n">Tep</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">q0</span><span class="p">)</span></div>

<div class="viewcode-block" id="ETS.ikine_GN"><a class="viewcode-back" href="../../../IK/stubs/roboticstoolbox.robot.ETS.ETS.ikine_GN.html#roboticstoolbox.robot.ETS.ETS.ikine_GN">[docs]</a>    <span class="k">def</span> <span class="nf">ikine_GN</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">joint_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">pinv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">km</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">ps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">pi</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gauss-Newton Numerical Inverse Kinematics Solver</span>

<span class="sd">        A method which provides functionality to perform numerical inverse kinematics (IK)</span>
<span class="sd">        using the Gauss-Newton method.</span>

<span class="sd">        See the :ref:`Inverse Kinematics Docs Page &lt;IK&gt;` for more details and for a</span>
<span class="sd">        **tutorial** on numerical IK, see `here &lt;https://bit.ly/3ak5GDi&gt;`_.</span>

<span class="sd">        Note</span>
<span class="sd">        ----</span>
<span class="sd">        When using this method with redundant robots (&gt;6 DoF), ``pinv`` must be set to ``True``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tep</span>
<span class="sd">            The desired end-effector pose</span>
<span class="sd">        q0</span>
<span class="sd">            The initial joint coordinate vector</span>
<span class="sd">        ilimit</span>
<span class="sd">            How many iterations are allowed within a search before a new search</span>
<span class="sd">            is started</span>
<span class="sd">        slimit</span>
<span class="sd">            How many searches are allowed before being deemed unsuccessful</span>
<span class="sd">        tol</span>
<span class="sd">            Maximum allowed residual error E</span>
<span class="sd">        mask</span>
<span class="sd">            A 6 vector which assigns weights to Cartesian degrees-of-freedom</span>
<span class="sd">            error priority</span>
<span class="sd">        joint_limits</span>
<span class="sd">            Reject solutions with joint limit violations</span>
<span class="sd">        seed</span>
<span class="sd">            A seed for the private RNG used to generate random joint coordinate</span>
<span class="sd">            vectors</span>
<span class="sd">        pinv</span>
<span class="sd">            If True, will use the psuedoinverse in the `step` method instead of</span>
<span class="sd">            the normal inverse</span>
<span class="sd">        kq</span>
<span class="sd">            The gain for joint limit avoidance. Setting to 0.0 will remove this</span>
<span class="sd">            completely from the solution</span>
<span class="sd">        km</span>
<span class="sd">            The gain for maximisation. Setting to 0.0 will remove this completely</span>
<span class="sd">            from the solution</span>
<span class="sd">        ps</span>
<span class="sd">            The minimum angle/distance (in radians or metres) in which the joint is</span>
<span class="sd">            allowed to approach to its limit</span>
<span class="sd">        pi</span>
<span class="sd">            The influence angle/distance (in radians or metres) in null space motion</span>
<span class="sd">            becomes active</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        Each iteration uses the Gauss-Newton optimisation method</span>

<span class="sd">        .. math::</span>

<span class="sd">            \vec{q}_{k+1} &amp;= \vec{q}_k +</span>
<span class="sd">            \left(</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}^\top</span>
<span class="sd">            \mat{W}_e \</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}</span>
<span class="sd">            \right)^{-1}</span>
<span class="sd">            \bf{g}_k \\</span>
<span class="sd">            \bf{g}_k &amp;=</span>
<span class="sd">            {\mat{J}(\vec{q}_k)}^\top</span>
<span class="sd">            \mat{W}_e</span>
<span class="sd">            \vec{e}_k</span>

<span class="sd">        where :math:`\mat{J} = {^0\mat{J}}` is the base-frame manipulator Jacobian. If</span>
<span class="sd">        :math:`\mat{J}(\vec{q}_k)` is non-singular, and :math:`\mat{W}_e = \mat{1}_n`, then</span>
<span class="sd">        the above provides the pseudoinverse solution. However, if :math:`\mat{J}(\vec{q}_k)`</span>
<span class="sd">        is singular, the above can not be computed and the GN solution is infeasible.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example gets the ``ets`` of a ``panda`` robot object, makes a goal</span>
<span class="sd">        pose ``Tep``, and then solves for the joint coordinates which result in the pose</span>
<span class="sd">        ``Tep`` using the `ikine_GN` method.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; Tep = panda.fkine([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>
<span class="sd">        &gt;&gt;&gt; panda.ikine_GN(Tep)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When using the this method, the initial joint coordinates :math:`q_0`, should correspond</span>
<span class="sd">        to a non-singular manipulator pose, since it uses the manipulator Jacobian.</span>

<span class="sd">        This class supports null-space motion to assist with maximising manipulability and</span>
<span class="sd">        avoiding joint limits. These are enabled by setting kq and km to non-zero values.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:class:`~roboticstoolbox.robot.IK.IK_NR`</span>
<span class="sd">            An IK Solver class which implements the Newton-Raphson optimisation technique</span>
<span class="sd">        ikine_LM</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_LM` class as a method within the :py:class:`ETS` class</span>
<span class="sd">        ikine_NR</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_NR` class as a method within the :py:class:`ETS` class</span>
<span class="sd">        ikine_QP</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_QP` class as a method within the :py:class:`ETS` class</span>


<span class="sd">        .. versionchanged:: 1.0.4</span>
<span class="sd">            Added the Gauss-Newton IK solver method on the `ETS` class</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="n">solver</span> <span class="o">=</span> <span class="n">IK_GN</span><span class="p">(</span>
            <span class="n">ilimit</span><span class="o">=</span><span class="n">ilimit</span><span class="p">,</span>
            <span class="n">slimit</span><span class="o">=</span><span class="n">slimit</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
            <span class="n">joint_limits</span><span class="o">=</span><span class="n">joint_limits</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">pinv</span><span class="o">=</span><span class="n">pinv</span><span class="p">,</span>
            <span class="n">kq</span><span class="o">=</span><span class="n">kq</span><span class="p">,</span>
            <span class="n">km</span><span class="o">=</span><span class="n">km</span><span class="p">,</span>
            <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">,</span>
            <span class="n">pi</span><span class="o">=</span><span class="n">pi</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># if isinstance(Tep, SE3):</span>
        <span class="c1">#     Tep = Tep.A</span>

        <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">ets</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">Tep</span><span class="o">=</span><span class="n">Tep</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">q0</span><span class="p">)</span></div>

<div class="viewcode-block" id="ETS.ikine_QP"><a class="viewcode-back" href="../../../IK/stubs/roboticstoolbox.robot.ETS.ETS.ikine_QP.html#roboticstoolbox.robot.ETS.ETS.ikine_QP">[docs]</a>    <span class="k">def</span> <span class="nf">ikine_QP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">Tep</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE3</span><span class="p">],</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ilimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
        <span class="n">slimit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
        <span class="n">mask</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">joint_limits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">seed</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kj</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">ks</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">kq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">km</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">ps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">pi</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Quadratic Programming Numerical Inverse Kinematics Solver</span>

<span class="sd">        A method that provides functionality to perform numerical inverse kinematics</span>
<span class="sd">        (IK) using a quadratic progamming approach.</span>

<span class="sd">        See the :ref:`Inverse Kinematics Docs Page &lt;IK&gt;` for more details and for a</span>
<span class="sd">        **tutorial** on numerical IK, see `here &lt;https://bit.ly/3ak5GDi&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Tep</span>
<span class="sd">            The desired end-effector pose</span>
<span class="sd">        q0</span>
<span class="sd">            The initial joint coordinate vector</span>
<span class="sd">        ilimit</span>
<span class="sd">            How many iterations are allowed within a search before a new search</span>
<span class="sd">            is started</span>
<span class="sd">        slimit</span>
<span class="sd">            How many searches are allowed before being deemed unsuccessful</span>
<span class="sd">        tol</span>
<span class="sd">            Maximum allowed residual error E</span>
<span class="sd">        mask</span>
<span class="sd">            A 6 vector which assigns weights to Cartesian degrees-of-freedom</span>
<span class="sd">            error priority</span>
<span class="sd">        joint_limits</span>
<span class="sd">            Reject solutions with joint limit violations</span>
<span class="sd">        seed</span>
<span class="sd">            A seed for the private RNG used to generate random joint coordinate</span>
<span class="sd">            vectors</span>
<span class="sd">        kj</span>
<span class="sd">            A gain for joint velocity norm minimisation</span>
<span class="sd">        ks</span>
<span class="sd">            A gain which adjusts the cost of slack (intentional error)</span>
<span class="sd">        kq</span>
<span class="sd">            The gain for joint limit avoidance. Setting to 0.0 will remove this</span>
<span class="sd">            completely from the solution</span>
<span class="sd">        km</span>
<span class="sd">            The gain for maximisation. Setting to 0.0 will remove this completely</span>
<span class="sd">            from the solution</span>
<span class="sd">        ps</span>
<span class="sd">            The minimum angle/distance (in radians or metres) in which the joint is</span>
<span class="sd">            allowed to approach to its limit</span>
<span class="sd">        pi</span>
<span class="sd">            The influence angle/distance (in radians or metres) in null space motion</span>
<span class="sd">            becomes active</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ImportError</span>
<span class="sd">            If the package ``qpsolvers`` is not installed</span>

<span class="sd">        Synopsis</span>
<span class="sd">        --------</span>
<span class="sd">        Each iteration uses the following approach</span>

<span class="sd">        .. math::</span>

<span class="sd">            \vec{q}_{k+1} = \vec{q}_{k} + \dot{\vec{q}}.</span>

<span class="sd">        where the QP is defined as</span>

<span class="sd">        .. math::</span>

<span class="sd">            \min_x \quad f_o(\vec{x}) &amp;= \frac{1}{2} \vec{x}^\top \mathcal{Q} \vec{x}+ \mathcal{C}^\top \vec{x}, \\</span>
<span class="sd">            \text{subject to} \quad \mathcal{J} \vec{x} &amp;= \vec{\nu},  \\</span>
<span class="sd">            \mathcal{A} \vec{x} &amp;\leq \mathcal{B},  \\</span>
<span class="sd">            \vec{x}^- &amp;\leq \vec{x} \leq \vec{x}^+</span>

<span class="sd">        with</span>

<span class="sd">        .. math::</span>

<span class="sd">            \vec{x} &amp;=</span>
<span class="sd">            \begin{pmatrix}</span>
<span class="sd">                \dvec{q} \\ \vec{\delta}</span>
<span class="sd">            \end{pmatrix} \in \mathbb{R}^{(n+6)}  \\</span>
<span class="sd">            \mathcal{Q} &amp;=</span>
<span class="sd">            \begin{pmatrix}</span>
<span class="sd">                \lambda_q \mat{1}_{n} &amp; \mathbf{0}_{6 \times 6} \\ \mathbf{0}_{n \times n} &amp; \lambda_\delta \mat{1}_{6}</span>
<span class="sd">            \end{pmatrix} \in \mathbb{R}^{(n+6) \times (n+6)} \\</span>
<span class="sd">            \mathcal{J} &amp;=</span>
<span class="sd">            \begin{pmatrix}</span>
<span class="sd">                \mat{J}(\vec{q}) &amp; \mat{1}_{6}</span>
<span class="sd">            \end{pmatrix} \in \mathbb{R}^{6 \times (n+6)} \\</span>
<span class="sd">            \mathcal{C} &amp;=</span>
<span class="sd">            \begin{pmatrix}</span>
<span class="sd">                \mat{J}_m \\ \bf{0}_{6 \times 1}</span>
<span class="sd">            \end{pmatrix} \in \mathbb{R}^{(n + 6)} \\</span>
<span class="sd">            \mathcal{A} &amp;=</span>
<span class="sd">            \begin{pmatrix}</span>
<span class="sd">                \mat{1}_{n \times n + 6} \\</span>
<span class="sd">            \end{pmatrix} \in \mathbb{R}^{(l + n) \times (n + 6)} \\</span>
<span class="sd">            \mathcal{B} &amp;=</span>
<span class="sd">            \eta</span>
<span class="sd">            \begin{pmatrix}</span>
<span class="sd">                \frac{\rho_0 - \rho_s}</span>
<span class="sd">                        {\rho_i - \rho_s} \\</span>
<span class="sd">                \vdots \\</span>
<span class="sd">                \frac{\rho_n - \rho_s}</span>
<span class="sd">                        {\rho_i - \rho_s}</span>
<span class="sd">            \end{pmatrix} \in \mathbb{R}^{n} \\</span>
<span class="sd">            \vec{x}^{-, +} &amp;=</span>
<span class="sd">            \begin{pmatrix}</span>
<span class="sd">                \dvec{q}^{-, +} \\</span>
<span class="sd">                \vec{\delta}^{-, +}</span>
<span class="sd">            \end{pmatrix} \in \mathbb{R}^{(n+6)},</span>

<span class="sd">        where :math:`\vec{\delta} \in \mathbb{R}^6` is the slack vector,</span>
<span class="sd">        :math:`\lambda_\delta \in \mathbb{R}^+` is a gain term which adjusts the</span>
<span class="sd">        cost of the norm of the slack vector in the optimiser,</span>
<span class="sd">        :math:`\dvec{q}^{-,+}` are the minimum and maximum joint velocities, and</span>
<span class="sd">        :math:`\dvec{\delta}^{-,+}` are the minimum and maximum slack velocities.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The following example gets the ``ets`` of a ``panda`` robot object, makes a goal</span>
<span class="sd">        pose ``Tep``, and then solves for the joint coordinates which result in the pose</span>
<span class="sd">        ``Tep`` using the `ikine_QP` method.</span>

<span class="sd">        .. runblock:: pycon</span>
<span class="sd">        &gt;&gt;&gt; import roboticstoolbox as rtb</span>
<span class="sd">        &gt;&gt;&gt; panda = rtb.models.Panda().ets()</span>
<span class="sd">        &gt;&gt;&gt; Tep = panda.fkine([0, -0.3, 0, -2.2, 0, 2, 0.7854])</span>
<span class="sd">        &gt;&gt;&gt; panda.ikine_QP(Tep)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        When using the this method, the initial joint coordinates :math:`q_0`, should correspond</span>
<span class="sd">        to a non-singular manipulator pose, since it uses the manipulator Jacobian.</span>

<span class="sd">        This class supports null-space motion to assist with maximising manipulability and</span>
<span class="sd">        avoiding joint limits. These are enabled by setting kq and km to non-zero values.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part I:</span>
<span class="sd">          Kinematics, Velocity, and Applications.&quot; arXiv preprint arXiv:2207.01796 (2022).</span>
<span class="sd">        - J. Haviland, and P. Corke. &quot;Manipulator Differential Kinematics Part II:</span>
<span class="sd">          Acceleration and Advanced Applications.&quot; arXiv preprint arXiv:2207.01794 (2022).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:class:`~roboticstoolbox.robot.IK.IK_NR`</span>
<span class="sd">            An IK Solver class which implements the Newton-Raphson optimisation technique</span>
<span class="sd">        ikine_LM</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_LM` class as a method within the :py:class:`ETS` class</span>
<span class="sd">        ikine_GN</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_GN` class as a method within the :py:class:`ETS` class</span>
<span class="sd">        ikine_NR</span>
<span class="sd">            Implements the :py:class:`~roboticstoolbox.robot.IK.IK_NR` class as a method within the :py:class:`ETS` class</span>


<span class="sd">        .. versionchanged:: 1.0.4</span>
<span class="sd">            Added the Quadratic Programming IK solver method on the `ETS` class</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>

        <span class="n">solver</span> <span class="o">=</span> <span class="n">IK_QP</span><span class="p">(</span>
            <span class="n">ilimit</span><span class="o">=</span><span class="n">ilimit</span><span class="p">,</span>
            <span class="n">slimit</span><span class="o">=</span><span class="n">slimit</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">,</span>
            <span class="n">joint_limits</span><span class="o">=</span><span class="n">joint_limits</span><span class="p">,</span>
            <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
            <span class="n">kj</span><span class="o">=</span><span class="n">kj</span><span class="p">,</span>
            <span class="n">ks</span><span class="o">=</span><span class="n">ks</span><span class="p">,</span>
            <span class="n">kq</span><span class="o">=</span><span class="n">kq</span><span class="p">,</span>
            <span class="n">km</span><span class="o">=</span><span class="n">km</span><span class="p">,</span>
            <span class="n">ps</span><span class="o">=</span><span class="n">ps</span><span class="p">,</span>
            <span class="n">pi</span><span class="o">=</span><span class="n">pi</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># if isinstance(Tep, SE3):</span>
        <span class="c1">#     Tep = Tep.A</span>

        <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">ets</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">Tep</span><span class="o">=</span><span class="n">Tep</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">q0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="ETS2"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2">[docs]</a><span class="k">class</span> <span class="nc">ETS2</span><span class="p">(</span><span class="n">BaseETS</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class implements an elementary transform sequence (ETS) for 2D</span>

<span class="sd">    :param arg: Function to compute ET value</span>

<span class="sd">    An instance can contain an elementary transform (ET) or an elementary</span>
<span class="sd">    transform sequence (ETS). It has list-like properties by subclassing</span>
<span class="sd">    UserList, which means we can perform indexing, slicing pop, insert, as well</span>
<span class="sd">    as using it as an iterator over its values.</span>

<span class="sd">    - ``ETS()`` an empty ETS list</span>
<span class="sd">    - ``ET2.XY(Œ∑)`` is a constant elementary transform</span>
<span class="sd">    - ``ET2.XY(Œ∑, &#39;deg&#39;)`` as above but the angle is expressed in degrees</span>
<span class="sd">    - ``ET2.XY()`` is a joint variable, the value is left free until evaluation</span>
<span class="sd">      time</span>
<span class="sd">    - ``ET2.XY(j=J)`` as above but the joint index is explicitly given, this</span>
<span class="sd">      might correspond to the joint number of a multi-joint robot.</span>
<span class="sd">    - ``ET2.XY(flip=True)`` as above but the joint moves in the opposite sense</span>

<span class="sd">    where ``XY`` is one of ``R``, ``tx``, ``ty``.</span>

<span class="sd">    Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ETS2 as ET2</span>
<span class="sd">            &gt;&gt;&gt; e = ET2.R(0.3)  # a single ET, rotation about z</span>
<span class="sd">            &gt;&gt;&gt; len(e)</span>
<span class="sd">            &gt;&gt;&gt; e = ET2.R(0.3) * ET2.tx(2)  # an ETS</span>
<span class="sd">            &gt;&gt;&gt; len(e)                      # of length 2</span>
<span class="sd">            &gt;&gt;&gt; e[1]                        # an ET sliced from the ETS</span>

<span class="sd">    :references:</span>
<span class="sd">        - Kinematic Derivatives using the Elementary Transform Sequence,</span>
<span class="sd">          J. Haviland and P. Corke</span>

<span class="sd">    :seealso: :func:`r`, :func:`tx`, :func:`ty`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="n">ET2</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">ET2</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="s2">&quot;ETS2&quot;</span><span class="p">],</span> <span class="n">ET2</span><span class="p">,</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">,</span> <span class="kc">None</span>
        <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ET2</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ETS2</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ets_item</span> <span class="ow">in</span> <span class="n">item</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ets_item</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;bad arg&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ET2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">arg</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ETS2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ets_item</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">ets_item</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid arg&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ndims</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check if jindices are set</span>
        <span class="n">joints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">joints</span><span class="p">()</span>

        <span class="c1"># Number of joints with a jindex</span>
        <span class="n">jindices</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Number of joints with a sequential jindex (j[2] -&gt; jindex = 2)</span>
        <span class="n">seq_jindex</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Count them up</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">joint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">joints</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jindices</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">seq_jindex</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">jindices</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">seq_jindex</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="ow">and</span> <span class="n">joints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="c1"># ets has sequential jindicies, except for the last.</span>
            <span class="n">joints</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">jindices</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">jindices</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;You can not have some jindices set for the ET&#39;s in arg. It must be all&quot;</span>
                <span class="s2">&quot; or none&quot;</span>
            <span class="p">)</span>  <span class="c1"># pragma: nocover</span>
        <span class="k">elif</span> <span class="n">jindices</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Set them ourself</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">joint</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">joints</span><span class="p">):</span>
                <span class="n">joint</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="n">j</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_auto_jindex</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="ETS2.__mul__"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.__mul__">[docs]</a>    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ET2</span><span class="p">,</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ET2</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ETS2</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">other</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ETS2</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="o">*</span><span class="n">other</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>  <span class="c1"># pragma: nocover</span></div>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ET2</span><span class="p">,</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ETS2</span><span class="p">([</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">:</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">rest</span>  <span class="c1"># pragma: nocover</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">rest</span><span class="p">)</span>  <span class="c1"># pragma: nocover</span>

<div class="viewcode-block" id="ETS2.compile"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.compile">[docs]</a>    <span class="k">def</span> <span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile an ETS2</span>

<span class="sd">        :return: optimised ETS2</span>

<span class="sd">        Perform constant folding for faster evaluation.  Consecutive constant</span>
<span class="sd">        ETs are compounded, leading to a constant ET which is denoted by</span>
<span class="sd">        ``SE3`` when displayed.</span>

<span class="sd">        :seealso: :func:`isconstant`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">const</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ets</span> <span class="o">=</span> <span class="n">ETS2</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">et</span><span class="o">.</span><span class="n">isjoint</span><span class="p">:</span>
                <span class="c1"># a joint</span>
                <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># flush the constant</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
                        <span class="n">ets</span> <span class="o">*=</span> <span class="n">ET2</span><span class="o">.</span><span class="n">SE2</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ets</span> <span class="o">*=</span> <span class="n">et</span>  <span class="c1"># emit the joint ET</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># not a joint</span>
                <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="n">et</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">const</span> <span class="o">=</span> <span class="n">const</span> <span class="o">@</span> <span class="n">et</span><span class="o">.</span><span class="n">A</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">const</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># flush the constant, tool transform</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">const</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>
                <span class="n">ets</span> <span class="o">*=</span> <span class="n">ET2</span><span class="o">.</span><span class="n">SE2</span><span class="p">(</span><span class="n">const</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ets</span></div>

<div class="viewcode-block" id="ETS2.insert"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ET2</span><span class="p">,</span> <span class="s2">&quot;ETS2&quot;</span><span class="p">],</span>
        <span class="n">i</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Insert value</span>

<span class="sd">        :param i: insert an ET or ETS into the ETS, default is at the end</span>
<span class="sd">        :param arg: the elementary transform or sequence to insert</span>

<span class="sd">        Inserts an ET or ETS into the ET sequence.  The inserted value is at position</span>
<span class="sd">        ``i``.</span>

<span class="sd">        Example:</span>

<span class="sd">        .. runblock:: pycon</span>

<span class="sd">            &gt;&gt;&gt; from roboticstoolbox import ET2</span>
<span class="sd">            &gt;&gt;&gt; e = ET2.R() * ET2.tx(1) * ET2.R() * ET2.tx(1)</span>
<span class="sd">            &gt;&gt;&gt; f = ET2.R()</span>
<span class="sd">            &gt;&gt;&gt; e.insert(f, 2)</span>
<span class="sd">            &gt;&gt;&gt; e</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ET2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">ETS2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">et</span> <span class="ow">in</span> <span class="n">arg</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">et</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">et</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">et</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_internals</span><span class="p">()</span></div>

<div class="viewcode-block" id="ETS2.fkine"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.fkine">[docs]</a>    <span class="k">def</span> <span class="nf">fkine</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE2</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE2</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_base</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SE2</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward kinematics</span>
<span class="sd">        :param q: Joint coordinates</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param base: base transform, optional</span>
<span class="sd">        :param tool: tool transform, optional</span>

<span class="sd">        :return: The transformation matrix representing the pose of the</span>
<span class="sd">            end-effector</span>

<span class="sd">        - ``T = ets.fkine(q)`` evaluates forward kinematics for the robot at</span>
<span class="sd">          joint configuration ``q``.</span>
<span class="sd">        **Trajectory operation**:</span>
<span class="sd">        If ``q`` has multiple rows (mxn), it is considered a trajectory and the</span>
<span class="sd">        result is an ``SE2`` instance with ``m`` values.</span>
<span class="sd">        .. note::</span>
<span class="sd">            - The robot&#39;s base tool transform, if set, is incorporated</span>
<span class="sd">              into the result.</span>
<span class="sd">            - A tool transform, if provided, is incorporated into the result.</span>
<span class="sd">            - Works from the end-effector link to the base</span>
<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">              Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">SE2</span><span class="o">.</span><span class="n">Empty</span><span class="p">()</span>
        <span class="n">fk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">tool</span><span class="p">,</span> <span class="n">include_base</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fk</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s2">&quot;O&quot;</span><span class="p">:</span>
            <span class="c1"># symbolic</span>
            <span class="n">fk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">simplify</span><span class="p">(</span><span class="n">fk</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">fk</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">fk</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SE2</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">SE2</span><span class="p">(</span><span class="n">fk</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">base</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE2</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tool</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">NDArray</span><span class="p">,</span> <span class="n">SE2</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">include_base</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Forward kinematics</span>
<span class="sd">        :param q: Joint coordinates</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :param base: base transform, optional</span>
<span class="sd">        :param tool: tool transform, optional</span>

<span class="sd">        :return: The transformation matrix representing the pose of the</span>
<span class="sd">            end-effector</span>

<span class="sd">        - ``T = ets.fkine(q)`` evaluates forward kinematics for the robot at</span>
<span class="sd">          joint configuration ``q``.</span>
<span class="sd">        **Trajectory operation**:</span>
<span class="sd">        If ``q`` has multiple rows (mxn), it is considered a trajectory and the</span>
<span class="sd">        result is an ``SE2`` instance with ``m`` values.</span>
<span class="sd">        .. note::</span>
<span class="sd">            - The robot&#39;s base tool transform, if set, is incorporated</span>
<span class="sd">              into the result.</span>
<span class="sd">            - A tool transform, if provided, is incorporated into the result.</span>
<span class="sd">            - Works from the end-effector link to the base</span>
<span class="sd">        :references:</span>
<span class="sd">            - Kinematic Derivatives using the Elementary Transform</span>
<span class="sd">              Sequence, J. Haviland and P. Corke</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">q</span> <span class="o">=</span> <span class="n">getmatrix</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># type: ignore</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">SE2</span><span class="p">):</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">bases</span> <span class="o">=</span> <span class="n">base</span>

        <span class="k">if</span> <span class="n">tool</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">SE2</span><span class="p">):</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tool</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">tool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)):</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
            <span class="n">tools</span> <span class="o">=</span> <span class="n">tool</span>

        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">l</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">qk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
            <span class="n">link</span> <span class="o">=</span> <span class="n">end</span>  <span class="c1"># start with last link</span>

            <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>
            <span class="n">Tk</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">qk</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">tools</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tk</span> <span class="o">=</span> <span class="n">Tk</span> <span class="o">@</span> <span class="n">tools</span>

            <span class="c1"># add remaining links, back toward the base</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">link</span><span class="o">.</span><span class="n">isjoint</span> <span class="k">else</span> <span class="n">link</span><span class="o">.</span><span class="n">jindex</span>
                <span class="n">A</span> <span class="o">=</span> <span class="n">link</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">qk</span><span class="p">[</span><span class="n">jindex</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">A</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">Tk</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">Tk</span>

            <span class="c1"># add base transform if it is set</span>
            <span class="k">if</span> <span class="n">include_base</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">bases</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">Tk</span> <span class="o">=</span> <span class="n">bases</span> <span class="o">@</span> <span class="n">Tk</span>

            <span class="c1"># append</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Tk</span>
                <span class="c1"># ret.append(SE2(Tk, check=False))  # type: ignore</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">Tk</span>
                <span class="c1"># ret = SE2(Tk, check=False)</span>

        <span class="k">return</span> <span class="n">T</span>

<div class="viewcode-block" id="ETS2.jacob0"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.jacob0">[docs]</a>    <span class="k">def</span> <span class="nf">jacob0</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
        <span class="c1"># very inefficient implementation, just put a 1 in last row</span>
        <span class="c1"># if its a rotation joint</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">getvector</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">J</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">))</span>
        <span class="n">etjoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">joint_idx</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">etjoints</span><span class="p">])):</span>
            <span class="c1"># not all joints have a jindex it is required, set them</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">etjoints</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="o">=</span> <span class="n">j</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">etjoints</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">jindex</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">jindex</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">jindex</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># pragma: nocover</span>

            <span class="c1"># jindex = 0 if self[i].jindex is None else self[i].jindex</span>

            <span class="n">axis</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">axis</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;R&quot;</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="o">@</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">A</span><span class="p">(</span>
                    <span class="n">q</span><span class="p">[</span><span class="n">jindex</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;tx&quot;</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s2">&quot;ty&quot;</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># pragma: nocover</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid axes&quot;</span><span class="p">)</span>

            <span class="n">E0</span> <span class="o">=</span> <span class="n">ETS2</span><span class="p">(</span><span class="bp">self</span><span class="p">[:</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">E0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">E0</span><span class="o">.</span><span class="n">fkine</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">A</span> <span class="o">@</span> <span class="n">dTdq</span>

            <span class="n">Ef</span> <span class="o">=</span> <span class="n">ETS2</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ef</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dTdq</span> <span class="o">=</span> <span class="n">dTdq</span> <span class="o">@</span> <span class="n">Ef</span><span class="o">.</span><span class="n">fkine</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">A</span>

            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fkine</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="o">.</span><span class="n">A</span>
            <span class="n">dRdt</span> <span class="o">=</span> <span class="n">dTdq</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">T</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

            <span class="n">J</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dTdq</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="n">J</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dRdt</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">J</span></div>

<div class="viewcode-block" id="ETS2.jacobe"><a class="viewcode-back" href="../../../arm_ets.html#roboticstoolbox.robot.ETS.ETS2.jacobe">[docs]</a>    <span class="k">def</span> <span class="nf">jacobe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">q</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Jacobian in base frame</span>

<span class="sd">        :param q: joint coordinates</span>
<span class="sd">        :type q: ArrayLike</span>
<span class="sd">        :return: Jacobian matrix</span>

<span class="sd">        ``jacobe(q)`` is the manipulator Jacobian matrix which maps joint</span>
<span class="sd">        velocity to end-effector spatial velocity.</span>

<span class="sd">        End-effector spatial velocity :math:`\nu = (v_x, v_y, v_z, \omega_x, \omega_y, \omega_z)^T`</span>
<span class="sd">        is related to joint velocity by :math:`{}^{e}\nu = {}^{e}\mathbf{J}_0(q) \dot{q}`.</span>

<span class="sd">        :seealso: :func:`jacob`, :func:`hessian0`</span>
<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fkine</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">include_base</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">A</span>
        <span class="k">return</span> <span class="n">tr2jac2</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacob0</span><span class="p">(</span><span class="n">q</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Jesse Haviland and Peter Corke.
      <span class="lastupdated">Last updated on 15-May-2023.
      </span></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
    <!-- Theme Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-11Q6WJM565"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-11Q6WJM565', {
          'anonymize_ip': false,
      });
    </script> 

</body>
</html>